<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æœ¨ç­æ±‚ç”Ÿ</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}body{overflow:hidden;background:#000;font-family:Arial,sans-serif}canvas{display:block}
#hud{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}
#crosshair{display:none}
#toolbar{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:6px;pointer-events:auto}
.toolbar-slot{width:60px;height:60px;border:2px solid rgba(255,255,255,0.4);border-radius:8px;background:rgba(0,0,0,0.5);display:flex;flex-direction:column;align-items:center;justify-content:center;color:#fff;font-size:12px;cursor:pointer;position:relative;transition:border-color 0.2s}
.toolbar-slot.active{border-color:#f0c040;background:rgba(240,192,64,0.2)}
.toolbar-slot .icon{font-size:22px;line-height:1}.toolbar-slot .label{font-size:10px;margin-top:2px}
.toolbar-slot .count{position:absolute;top:2px;right:4px;font-size:10px;color:#f0c040}
.toolbar-slot .key-hint{position:absolute;top:2px;left:4px;font-size:9px;color:rgba(255,255,255,0.5)}
#tooltip{position:absolute;bottom:100px;left:50%;transform:translateX(-50%);color:#fff;font-size:14px;background:rgba(0,0,0,0.6);padding:6px 16px;border-radius:6px;opacity:0;transition:opacity 0.3s;white-space:nowrap}
#tooltip.show{opacity:1}
#collect-log{position:absolute;right:20px;top:50%;transform:translateY(-50%);display:flex;flex-direction:column;gap:4px;align-items:flex-end}
.collect-msg{color:#8f8;font-size:13px;background:rgba(0,0,0,0.5);padding:4px 10px;border-radius:4px;animation:cf 2s forwards}
@keyframes cf{0%{opacity:0;transform:translateX(20px)}15%{opacity:1;transform:translateX(0)}80%{opacity:1}100%{opacity:0;transform:translateY(-10px)}}
#build-menu{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.85);border:1px solid rgba(255,255,255,0.2);border-radius:12px;padding:20px;min-width:340px;max-height:70vh;color:#fff;display:none;pointer-events:auto;overflow-y:auto}
#build-menu h3{text-align:center;margin-bottom:12px;color:#f0c040;font-size:18px}
.build-item{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;margin:4px 0;background:rgba(255,255,255,0.05);border-radius:6px;cursor:pointer;transition:background 0.2s}
.build-item:hover{background:rgba(255,255,255,0.15)}.build-item.disabled{opacity:0.4;cursor:not-allowed}
#backpack-menu{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.88);border:1px solid rgba(255,255,255,0.25);border-radius:12px;padding:20px 24px;min-width:280px;max-height:70vh;color:#fff;display:none;pointer-events:auto;overflow-y:auto}
#backpack-menu h3{text-align:center;margin-bottom:14px;color:#f0c040;font-size:18px}
.backpack-item{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;margin:4px 0;background:rgba(255,255,255,0.06);border-radius:6px;transition:background 0.2s}
.backpack-item:hover{background:rgba(255,255,255,0.12)}
.backpack-item .bp-icon{font-size:18px;margin-right:10px;min-width:30px;text-align:center}
.backpack-item .bp-name{flex:1;font-size:14px}
.backpack-item .bp-count{font-size:16px;color:#f0c040;font-weight:bold;min-width:30px;text-align:right}
.backpack-empty{text-align:center;color:rgba(255,255,255,0.4);padding:20px;font-size:14px}
#backpack-menu .close-hint,#build-menu .close-hint{text-align:center;margin-top:12px;font-size:11px;color:rgba(255,255,255,0.35)}
#place-hint{position:absolute;top:60px;left:50%;transform:translateX(-50%);color:#f0c040;font-size:16px;background:rgba(0,0,0,0.7);padding:8px 20px;border-radius:8px;display:none;pointer-events:none;z-index:20}
body.placing-mode{cursor:pointer}
body.demolish-mode{cursor:crosshair}
#demolish-menu{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.88);border:1px solid rgba(255,80,80,0.4);border-radius:12px;padding:20px 24px;min-width:300px;max-height:70vh;color:#fff;display:none;pointer-events:auto;overflow-y:auto}
#demolish-menu h3{text-align:center;margin-bottom:14px;color:#ff6644;font-size:18px}
.demolish-item{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;margin:4px 0;background:rgba(255,80,80,0.08);border-radius:6px;cursor:pointer;transition:background 0.2s}
.demolish-item:hover{background:rgba(255,80,80,0.25)}
.demolish-item .dm-icon{font-size:18px;margin-right:10px;min-width:30px;text-align:center}
.demolish-item .dm-name{flex:1;font-size:14px}
.demolish-item .dm-refund{font-size:11px;color:#8f8;min-width:80px;text-align:right}
.demolish-empty{text-align:center;color:rgba(255,255,255,0.4);padding:20px;font-size:14px}
#demolish-menu .close-hint{text-align:center;margin-top:12px;font-size:11px;color:rgba(255,255,255,0.35)}
#start-screen{position:fixed;top:0;left:0;width:100%;height:100%;background:linear-gradient(180deg,#0a2a4a 0%,#0d4a7a 50%,#1a6a9a 100%);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100;color:#fff}
#start-screen h1{font-size:48px;margin-bottom:10px;text-shadow:0 2px 10px rgba(0,0,0,0.5)}
#start-screen p{font-size:16px;color:#aad;margin-bottom:30px}
.start-btn-group{display:flex;gap:12px;flex-direction:column;align-items:center}
#start-btn,#continue-btn{padding:14px 50px;font-size:20px;background:#f0c040;color:#333;border:none;border-radius:8px;cursor:pointer;font-weight:bold;transition:transform 0.2s}
#start-btn:hover,#continue-btn:hover{transform:scale(1.05)}
#continue-btn{background:#40c0f0}
#continue-btn:disabled{opacity:0.4;cursor:not-allowed;transform:none}
#save-indicator{position:fixed;top:12px;left:12px;color:rgba(255,255,255,0.6);font-size:12px;background:rgba(0,0,0,0.4);padding:4px 10px;border-radius:4px;z-index:30;opacity:0;transition:opacity 0.5s;pointer-events:none}
#save-indicator.show{opacity:1}
#controls-info{margin-top:40px;text-align:left;font-size:13px;color:#8ab;line-height:1.8}
#controls-info kbd{background:rgba(255,255,255,0.15);padding:2px 8px;border-radius:4px;font-family:monospace}
#fishing-hint{position:absolute;top:120px;left:50%;transform:translateX(-50%);color:#fff;font-size:16px;background:rgba(0,80,200,0.75);padding:8px 20px;border-radius:8px;display:none;pointer-events:none;z-index:20}
#fishing-bite{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;font-size:28px;font-weight:bold;background:rgba(200,80,0,0.85);padding:14px 32px;border-radius:12px;display:none;pointer-events:none;z-index:25;text-align:center}
</style>
</head>
<body>
<div id="save-indicator"></div>
<div id="start-screen">
<h1>&#x26F5; æœ¨ç­æ±‚ç”Ÿ</h1>
<p>åœ¨æ— å°½çš„æµ·æ´‹ä¸Šç”Ÿå­˜ï¼Œæ”¶é›†èµ„æºï¼Œæ‰©å»ºä½ çš„æœ¨ç­ã€‚</p>
<div class="start-btn-group">
<button id="start-btn">æ–°çš„æ¸¸æˆ</button>
<button id="continue-btn" disabled>ç»§ç»­æ¸¸æˆ</button>
</div>
<div id="controls-info">
<div><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> - æ§åˆ¶å°äººåœ¨æœ¨ç­ä¸Šè¡Œèµ°</div>
<div><kbd>Q</kbd><kbd>E</kbd> / <kbd>å³é”®æ‹–æ‹½</kbd> - è§†è§’æ§åˆ¶ï¼ˆç¯ç»•å°äººæ—‹è½¬ï¼‰</div>
<div><kbd>å·¦é”®ç‚¹å‡»</kbd> - ç‚¹å‡»è¿œå¤„ä½¿ç”¨å·¥å…·ï¼ˆåˆ’æ¡¨/æ•æï¼‰</div>
<div><kbd>1</kbd><kbd>2</kbd><kbd>3</kbd> - åˆ‡æ¢ï¼ˆé’©å­/é’“é±¼ / èˆ¹æ¡¨ / å»ºé€ ï¼‰<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;èƒŒåŒ…è£…å¤‡é±¼ç«¿åï¼Œé”®1å˜ä¸ºé’“é±¼</div>
<div><kbd>4</kbd> - èƒŒåŒ… &nbsp; <kbd>5</kbd> - ä¸Šå¸æ¨¡å¼ &nbsp; <kbd>6</kbd> - æ‹†é™¤ &nbsp; <kbd>7</kbd> - è§‚å¯Ÿæ¨¡å¼ &nbsp; <kbd>B</kbd> - å»ºé€ èœå• &nbsp; <kbd>ESC</kbd> - å…³é—­ç•Œé¢</div>
</div>
</div>
<div id="hud" style="display:none">
<div id="crosshair"></div><div id="toolbar"></div><div id="tooltip"></div>
<div id="collect-log"></div>
<div id="build-menu"><h3>å»ºé€ èœå• [B]</h3><div id="build-list"></div><div class="close-hint">æŒ‰ B æˆ– ESC å…³é—­</div></div>
<div id="backpack-menu"><h3>èƒŒåŒ… [4]</h3><div id="backpack-list"></div><div class="close-hint">æŒ‰ 4 æˆ– ESC å…³é—­</div></div>
<div id="demolish-menu"><h3>æ‹†é™¤èœå• [6]</h3><div id="demolish-list"></div><div class="close-hint">æŒ‰ 6 æˆ– ESC å…³é—­</div></div>
<div id="place-hint">ç‚¹å‡»æœ¨ç­å‘¨å›´çš„é«˜äº®åŒºåŸŸæ”¾ç½®æœ¨æ¿ï¼ˆESC å–æ¶ˆï¼‰</div>
<div id="fishing-hint">è£…å¤‡é±¼ç«¿åï¼Œç‚¹å‡»æµ·é¢æŠ•æ·é’©å­é’“é±¼</div>
<div id="fishing-bite">ğŸŸ é±¼ä¸Šé’©äº†ï¼å¿«ç‚¹å‡»é‚£æ¡é±¼ï¼</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
/* ============================================================
 * Raft Survival - 3D Game (Three.js r128)
 *
 * Features:
 *  - Infinite calm ocean (plane follows camera)
 *  - Expandable raft (grid-based plank system)
 *  - Floating items spawn randomly on sea (wood, rope, plastic, iron, copper, gold)
 *  - Hook tool to grab items from water
 *  - Paddle tool to push raft forward toward clicked target
 *  - Build system to expand raft with collected resources
 *  - Backpack UI for viewing inventory
 *  - WASD + mouse first-person camera (disabled when UI panels are open)
 *
 * Classes: Game, Ocean, Raft, Player, InputManager, Hook, Paddle,
 *          ItemSpawner, FloatingItem, Inventory, BuildSystem, UIManager
 * ============================================================ */

/* ===== CONFIG ===== */
var CONFIG = {
  OCEAN_SIZE: 2000, OCEAN_COLOR: 0x0077be, OCEAN_SEG: 128,
  SKY: 0x87ceeb, FOG: 0xb0d4f1, FOG_N: 100, FOG_F: 600,
  PH: 2.0, MS: 0.002, LS: 2.0,           // player height, mouse sens, look speed
  CHAR_SPEED: 3.0,                         // character walk speed
  CAM_DIST: 5.0,                           // third-person camera distance (default)
  CAM_DIST_MIN: 2.0,                       // minimum zoom distance
  CAM_DIST_MAX: 20.0,                      // maximum zoom distance
  CAM_ZOOM_SPEED: 0.8,                     // zoom speed per scroll step
  CAM_HEIGHT: 3.5,                         // third-person camera height offset
  CAM_PITCH_MIN: 0.1,                      // minimum camera pitch (looking down)
  CAM_PITCH_MAX: 1.2,                      // maximum camera pitch
  CAM_KEY_ROTATE_SPEED: 2.0,               // Q/E key rotation speed (radians per second)
  RPS: 2, RPH: 0.3, RY: 0.15,            // raft plank size/height/y
  SI: 2.0, SMX: 30, SRN: 15, SRX: 80,    // spawn interval/max/radius
  FY: 0.15, DS: 0.3,                       // float y, drift speed
  HR: 100, HS: 15, HPS: 10, HGR: 2.5,     // hook range/speed/pull/grab
  PF: 8, PC: 0.5, RD: 0.98,              // paddle force/cooldown, raft drag
  PADDLE_SPEED: 3.0,                       // paddle continuous speed for raft movement
  PILLAR_H: 2.5,                           // pillar height (floor-to-floor)
  BR: { plank: { name: 'æ‰©å»ºæœ¨ç­', cost: { wood: 2, rope: 1 }, icon: 'ç­' },
        pillar: { name: 'æŸ±å­', cost: { wood: 3 }, icon: 'æŸ±' },
        stairs: { name: 'æ¥¼æ¢¯', cost: { iron: 2, wood: 4, rope: 1 }, icon: 'æ¢¯' },
        upper_plank: { name: 'ä¸Šå±‚æœ¨æ¿', cost: { wood: 2, rope: 1 }, icon: 'æ¿' },
        storage: { name: 'å‚¨ç‰©ç®±', cost: { wood: 4, rope: 2 }, icon: 'ç®±' },
        purifier: { name: 'æ·¡æ°´å‡€åŒ–å™¨', cost: { plastic: 6, rope: 4, copper: 2 }, icon: 'å‡€' },
        fishing_rod: { name: 'é±¼ç«¿', cost: { wood: 4, rope: 2, copper: 1 }, icon: 'ç«¿', craftOnly: true } }
};

/* Item types with visual properties */
var IT = {
  wood:    { name: 'æœ¨æ',  color: 0x8B6914, icon: 'æœ¨', sx: 1.2, sy: 0.15, sz: 0.5 },
  rope:    { name: 'ç»³å­',  color: 0xC4A35A, icon: 'ç»³', sx: 0.4, sy: 0.2,  sz: 0.4 },
  plastic: { name: 'å¡‘æ–™',  color: 0x44AA88, icon: 'å¡‘', sx: 0.5, sy: 0.2,  sz: 0.5 },
  iron:    { name: 'é“æ¿',  color: 0x888888, icon: 'é“', sx: 0.4, sy: 0.1,  sz: 0.6 },
  copper:  { name: 'é“œæ¿',  color: 0xB87333, icon: 'é“œ', sx: 0.4, sy: 0.1,  sz: 0.6 },
  gold:    { name: 'é‡‘å—',  color: 0xFFD700, icon: 'é‡‘', sx: 0.3, sy: 0.15, sz: 0.3 },
  freshwater: { name: 'æ·¡æ°´', color: 0x44aaff, icon: 'æ°´', sx: 0.3, sy: 0.3, sz: 0.3 },
  fish:    { name: 'é±¼',   color: 0xff8844, icon: 'é±¼', sx: 0.5, sy: 0.2,  sz: 0.3 }
};

/* ===== InputManager - keyboard and mouse input ===== */
class InputManager {
  constructor() {
    this.keys = new Set(); this.md = false; this.mjp = false;
    this.dx = 0; this.dy = 0;
    this.rmb = false; // Right mouse button held for camera rotation
    this.uiOpen = false; // When true, mouse does not control camera
    this.mouseX = 0; this.mouseY = 0; // Screen-space mouse position for free-cursor raycasting
    this.wheelDelta = 0; // Mouse wheel delta for layer switching
    var s = this;
    document.addEventListener('keydown', function(e) { s.keys.add(e.code) });
    document.addEventListener('keyup', function(e) { s.keys.delete(e.code) });
    document.addEventListener('mousemove', function(e) {
      if (s.rmb && !s.uiOpen) { s.dx += e.movementX; s.dy += e.movementY; }
      s.mouseX = e.clientX; s.mouseY = e.clientY;
    });
    document.addEventListener('mousedown', function(e) {
      if (e.button === 0) { s.md = true; s.mjp = true; }
      if (e.button === 2) { s.rmb = true; }
    });
    document.addEventListener('mouseup', function(e) {
      if (e.button === 0) s.md = false;
      if (e.button === 2) s.rmb = false;
    });
    document.addEventListener('contextmenu', function(e) { e.preventDefault(); });
    document.addEventListener('wheel', function(e) {
      s.wheelDelta += Math.sign(e.deltaY);
    });
  }
  kd(c) { return this.keys.has(c); }
  /* Get normalized device coordinates from current mouse position */
  getNDC(w, h) {
    return new THREE.Vector2((this.mouseX / w) * 2 - 1, -(this.mouseY / h) * 2 + 1);
  }
  reset() { this.dx = 0; this.dy = 0; this.mjp = false; this.wheelDelta = 0; }
}

/* ===== Ocean - infinite sea surface with depth gradient and ripples ===== */
class Ocean {
  constructor(sc) {
    this.sc = sc;
    var g = new THREE.PlaneGeometry(CONFIG.OCEAN_SIZE, CONFIG.OCEAN_SIZE, CONFIG.OCEAN_SEG, CONFIG.OCEAN_SEG);
    /* Custom shader: deep blue near camera, lighter blue far away, with ripple normal perturbation */
    this.oceanMat = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
        uCamPos: { value: new THREE.Vector3() },
        uSunDir: { value: new THREE.Vector3(0.5, 0.8, 0.3).normalize() },
        uDeepColor: { value: new THREE.Color(0x003366) },
        uMidColor: { value: new THREE.Color(0x0066aa) },
        uFarColor: { value: new THREE.Color(0x88bbdd) },
        uFogColor: { value: new THREE.Color(CONFIG.FOG) },
        uFogNear: { value: CONFIG.FOG_N },
        uFogFar: { value: CONFIG.FOG_F }
      },
      vertexShader: [
        'uniform float uTime;',
        'varying vec3 vWorldPos;',
        'varying float vDist;',
        'uniform vec3 uCamPos;',
        'void main(){',
        '  vec3 pos = position;',
        '  float wx = pos.x + uCamPos.x;',
        '  float wy = pos.y - uCamPos.z;',
        /* Gentle vertex wave displacement */
        '  pos.z = sin(wx * 0.05 + uTime * 0.5) * 0.08 + cos(wy * 0.07 + uTime * 0.3) * 0.05;',
        /* Secondary smaller ripple */
        '  pos.z += sin(wx * 0.15 + uTime * 0.8) * 0.02 + cos(wy * 0.12 + uTime * 0.6) * 0.02;',
        '  vWorldPos = vec3(pos.x + uCamPos.x, 0.0, pos.y - uCamPos.z);',
        '  vDist = length(vWorldPos - uCamPos);',
        '  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);',
        '}'
      ].join('\n'),
      fragmentShader: [
        'uniform float uTime;',
        'uniform vec3 uDeepColor;',
        'uniform vec3 uMidColor;',
        'uniform vec3 uFarColor;',
        'uniform vec3 uFogColor;',
        'uniform float uFogNear;',
        'uniform float uFogFar;',
        'uniform vec3 uSunDir;',
        'uniform vec3 uCamPos;',
        'varying vec3 vWorldPos;',
        'varying float vDist;',
        /* Multi-layer water surface normal - computed analytically to avoid 3x redundant trig */
        'vec3 getWaterNormal(vec2 p, float t) {',
        '  // Compute analytical partial derivatives dh/dx and dh/dy',
        '  // For h = A*sin(kx*x + ky*y + w*t): dh/dx = A*kx*cos(...), dh/dy = A*ky*cos(...)',
        '  float dhdx = 0.0, dhdy = 0.0;',
        '  float ph, c;',
        '  // Layer 1: sin(0.3x + 0.7t)*0.03 -> dhdx+=0.3*0.03*cos, dhdy+=0',
        '  ph = p.x * 0.3 + t * 0.7; c = cos(ph); dhdx += 0.3 * 0.03 * c;',
        '  // Layer 1: cos(0.25y + 0.5t)*0.025 -> dhdy+=-0.25*0.025*sin',
        '  ph = p.y * 0.25 + t * 0.5; c = sin(ph); dhdy += -0.25 * 0.025 * c;',
        '  // Layer 2: sin(0.8x + 0.6y + 1.2t)*0.012',
        '  ph = p.x * 0.8 + p.y * 0.6 + t * 1.2; c = cos(ph); dhdx += 0.8 * 0.012 * c; dhdy += 0.6 * 0.012 * c;',
        '  // Layer 2: cos(1.1x - 0.7y + 0.9t)*0.01 -> derivative of cos is -sin',
        '  ph = p.x * 1.1 - p.y * 0.7 + t * 0.9; c = sin(ph); dhdx += -1.1 * 0.01 * c; dhdy += 0.7 * 0.01 * c;',
        '  // Layer 3: sin(2.5x + 2.0t)*0.005',
        '  ph = p.x * 2.5 + t * 2.0; c = cos(ph); dhdx += 2.5 * 0.005 * c;',
        '  // Layer 3: cos(2.8y - 1.8t)*0.004 -> dhdy only',
        '  ph = p.y * 2.8 - t * 1.8; c = sin(ph); dhdy += -2.8 * 0.004 * c;',
        '  // Layer 3: sin(4.0x + 3.5y + 2.5t)*0.003',
        '  ph = p.x * 4.0 + p.y * 3.5 + t * 2.5; c = cos(ph); dhdx += 4.0 * 0.003 * c; dhdy += 3.5 * 0.003 * c;',
        '  // Layer 4: sin(8.0x + 3.0t)*0.002',
        '  ph = p.x * 8.0 + t * 3.0; c = cos(ph); dhdx += 8.0 * 0.002 * c;',
        '  // Layer 4: cos(9.0y - 3.5t)*0.0015',
        '  ph = p.y * 9.0 - t * 3.5; c = sin(ph); dhdy += -9.0 * 0.0015 * c;',
        '  // Layer 4: sin((x+y)*12.0 + 4.0t)*0.001',
        '  ph = (p.x + p.y) * 12.0 + t * 4.0; c = cos(ph); dhdx += 12.0 * 0.001 * c; dhdy += 12.0 * 0.001 * c;',
        '  return normalize(vec3(-dhdx, 1.0, -dhdy));',
        '}',
        '',
        'void main(){',
        /* Depth gradient: near=deep, far=light */
        '  float t1 = clamp(vDist / 120.0, 0.0, 1.0);',
        '  float t2 = clamp((vDist - 120.0) / 300.0, 0.0, 1.0);',
        '  vec3 baseColor = mix(uDeepColor, uMidColor, t1);',
        '  baseColor = mix(baseColor, uFarColor, t2);',
        '  ',
        '  // Get detailed water surface normal',
        '  vec3 N = getWaterNormal(vWorldPos.xz, uTime);',
        '  vec3 viewDir = normalize(uCamPos - vWorldPos);',
        '  ',
        '  // Softer, more natural specular highlights',
        '  vec3 halfDir = normalize(uSunDir + viewDir);',
        '  float NdotH = max(dot(N, halfDir), 0.0);',
        '  // Cache NdotH^15, then derive higher powers to avoid redundant pow() calls',
        '  float NdotH15 = pow(NdotH, 15.0);',
        '  float NdotH30 = NdotH15 * NdotH15;',
        '  float NdotH60 = NdotH30 * NdotH30;',
        '  float totalSpec = NdotH60 * 0.15 + NdotH30 * 0.2 + NdotH15 * 0.15;',
        '  ',
        '  // Distributed micro-sparkles (è¿ç»­åˆ†å¸ƒçš„ç»†ç¢å…‰æ–‘)',
        '  vec2 microCoord = vWorldPos.xz * 3.0;',
        '  float microWave1 = sin(microCoord.x * 1.2 + uTime * 1.5) * cos(microCoord.y * 1.1 - uTime * 1.3);',
        '  float microWave2 = cos(microCoord.x * 1.8 - uTime * 1.8) * sin(microCoord.y * 1.5 + uTime * 1.6);',
        '  float microWave3 = sin(microCoord.x * 2.5 + microCoord.y * 2.3 + uTime * 2.0) * 0.5;',
        '  ',
        '  // Smoother micro pattern',
        '  float microPattern = (microWave1 + microWave2 + microWave3) * 0.33 + 0.5;',
        '  microPattern = smoothstep(0.3, 0.7, microPattern);',
        '  // Gentle sparkle modulation (æŸ”å’Œçš„é—ªçƒ)',
        '  float microSpec = microPattern * pow(NdotH, 25.0) * 0.12;',
        '  ',
        '  // Fresnel effect (subtle)',
        '  float viewAngle = max(dot(N, viewDir), 0.0);',
        '  float fresnel = pow(1.0 - viewAngle, 3.0) * 0.2;',
        '  ',
        '  // Gentle angle boost',
        '  float angleBoost = 1.0 + (1.0 - viewAngle) * 0.8;',
        '  ',
        '  // Distance fade',
        '  float distFade = 1.0 - clamp(vDist / 250.0, 0.0, 1.0);',
        '  ',
        '  // Combine sparkles with lower intensity',
        '  vec3 sparkleColor = vec3(1.0, 1.0, 0.96);',
        '  vec3 sparkles = sparkleColor * (totalSpec + microSpec) * angleBoost * distFade * 0.6;',
        '  ',
        '  // Base color with subtle brightness variation',
        '  vec3 deepReflect = mix(baseColor, vec3(0.3, 0.6, 0.85), fresnel * 0.3);',
        '  ',
        '  // Final color with gentler composition',
        '  vec3 col = deepReflect + sparkles + vec3(fresnel * 0.08);',
        '  ',
        '  // Fog',
        '  float fogFactor = clamp((vDist - uFogNear) / (uFogFar - uFogNear), 0.0, 1.0);',
        '  col = mix(col, uFogColor, fogFactor);',
        '  ',
        '  gl_FragColor = vec4(col, 0.88);',
        '}'
      ].join('\n'),
      transparent: true,
      side: THREE.DoubleSide
    });
    this.mesh = new THREE.Mesh(g, this.oceanMat);
    this.mesh.rotation.x = -Math.PI / 2; this.mesh.receiveShadow = true; sc.add(this.mesh);
    var dg = new THREE.PlaneGeometry(CONFIG.OCEAN_SIZE, CONFIG.OCEAN_SIZE);
    var dm = new THREE.MeshBasicMaterial({ color: 0x001a33, side: THREE.DoubleSide });
    this.deep = new THREE.Mesh(dg, dm); this.deep.rotation.x = -Math.PI / 2; this.deep.position.y = -5; sc.add(this.deep);
  }
  /* Follow camera position + update shader uniforms */
  update(cp, t) {
    this.mesh.position.x = cp.x; this.mesh.position.z = cp.z;
    this.deep.position.x = cp.x; this.deep.position.z = cp.z;
    this.oceanMat.uniforms.uTime.value = t;
    this.oceanMat.uniforms.uCamPos.value.copy(cp);
  }
}

/* ===== Raft - expandable wooden platform (grid-based, multi-layer) ===== */
/* Sub-grid system: each plank is a 10x10 sub-grid.
 * Pillar occupies 2x2 sub-cells, Storage box occupies 3x3 sub-cells.
 * Sub-grid coordinates: (gx, gz, sx, sz) where sx,sz are 0..9 within the plank.
 * Items are placed at sub-grid positions and occupy a rectangular area. */
class Raft {
  constructor(sc) {
    this.sc = sc; this.g = new THREE.Group(); sc.add(this.g);
    this.planks = []; this.vel = new THREE.Vector3(); this.occ = new Set();
    /* Multi-layer structures: pillars, stairs, upper planks */
    this.pillars = [];    // { gx, gz, sx, sz, layer, mesh } - sx,sz are sub-grid position (top-left of 2x2)
    this.pillarOcc = new Map(); // "gx,gz,layer" -> Set of occupied sub-cells "sx,sz"
    this.stairs = [];     // { x, z, layer, mesh }
    this.stairOcc = new Set(); // "gx,gz,layer"
    this.upperPlanks = []; // { x, z, layer, mesh }
    this.upperOcc = new Set(); // "gx,gz,layer"
    /* Storage boxes with sub-grid positions */
    this.storages = [];   // { gx, gz, sx, sz, layer, mesh } - sx,sz top-left of 3x3
    this.storageOcc = new Map(); // "gx,gz,layer" -> Set of occupied sub-cells "sx,sz"
    this.addPlank(0, 0); // Start with one plank
  }
  /* Create a plank mesh with wood grain */
  _createPlankMesh(gx, gz, y) {
    var s = CONFIG.RPS, geo = new THREE.BoxGeometry(s, CONFIG.RPH, s);
    var mat = new THREE.MeshLambertMaterial({ color: 0x8B6914 });
    var m = new THREE.Mesh(geo, mat); m.castShadow = true; m.receiveShadow = true;
    m.position.set(gx * s, y, gz * s); this.g.add(m);
    var lc = 0x6B4F12;
    for (var i = -1; i <= 1; i++) { var lg = new THREE.BoxGeometry(s - 0.1, CONFIG.RPH + 0.01, 0.04);
      var ln = new THREE.Mesh(lg, new THREE.MeshLambertMaterial({ color: lc }));
      ln.position.set(0, 0.005, i * 0.55); m.add(ln); }
    var gg = new THREE.BoxGeometry(0.04, CONFIG.RPH + 0.01, s - 0.1);
    var gp = new THREE.Mesh(gg, new THREE.MeshLambertMaterial({ color: lc }));
    gp.position.set(0, 0.005, 0); m.add(gp);
    return m;
  }
  /* Add a ground-level plank at grid position */
  addPlank(gx, gz) {
    var k = gx + ',' + gz; if (this.occ.has(k)) return false;
    var m = this._createPlankMesh(gx, gz, 0);
    this.planks.push({ x: gx, z: gz, mesh: m }); this.occ.add(k); return true;
  }
  /* Check if a rectangular area of sub-cells is free on a plank for a given occupancy map */
  _subgridFree(occMap, gx, gz, layer, sx, sz, w, h) {
    var key = gx + ',' + gz + ',' + layer;
    var cells = occMap.get(key);
    if (!cells) return true;
    for (var dx = 0; dx < w; dx++) {
      for (var dz = 0; dz < h; dz++) {
        if (cells.has((sx + dx) + ',' + (sz + dz))) return false;
      }
    }
    return true;
  }
  /* Mark sub-cells as occupied */
  _subgridMark(occMap, gx, gz, layer, sx, sz, w, h) {
    var key = gx + ',' + gz + ',' + layer;
    if (!occMap.has(key)) occMap.set(key, new Set());
    var cells = occMap.get(key);
    for (var dx = 0; dx < w; dx++) {
      for (var dz = 0; dz < h; dz++) {
        cells.add((sx + dx) + ',' + (sz + dz));
      }
    }
  }
  /* Check if sub-area overlaps with ANY occupancy (pillars + storages) */
  _subgridFreeAll(gx, gz, layer, sx, sz, w, h) {
    return this._subgridFree(this.pillarOcc, gx, gz, layer, sx, sz, w, h) &&
           this._subgridFree(this.storageOcc, gx, gz, layer, sx, sz, w, h);
  }
  /* Convert sub-grid position to world offset within a plank.
   * Plank is CONFIG.RPS x CONFIG.RPS. Sub-grid is 10x10.
   * Sub-cell (0,0) is at plank corner (-RPS/2, -RPS/2), (9,9) at (+RPS/2 - cellSize, +RPS/2 - cellSize) */
  _subToWorld(gx, gz, sx, sz, w, h) {
    var s = CONFIG.RPS;
    var cellSize = s / 10;
    var cx = gx * s - s / 2 + (sx + w / 2) * cellSize;
    var cz = gz * s - s / 2 + (sz + h / 2) * cellSize;
    return { x: cx, z: cz };
  }
  /* Add a pillar (vertical column) at sub-grid position on given layer (0 = ground).
   * Pillar is 2x2 sub-cells. sx, sz are top-left sub-cell coordinates (0..8). */
  addPillar(gx, gz, layer, sx, sz) {
    layer = layer || 0;
    sx = (sx !== undefined) ? sx : 4; // default center
    sz = (sz !== undefined) ? sz : 4;
    /* Bounds check: 2x2 must fit in 0..9 */
    if (sx < 0 || sx > 8 || sz < 0 || sz > 8) return false;
    /* Check that there is a base plank or upper plank below */
    if (layer === 0) { if (!this.occ.has(gx + ',' + gz)) return false; }
    else { if (!this.upperOcc.has(gx + ',' + gz + ',' + layer)) return false; }
    /* Check sub-grid is free */
    if (!this._subgridFreeAll(gx, gz, layer, sx, sz, 2, 2)) return false;
    var s = CONFIG.RPS, ph = CONFIG.PILLAR_H;
    var cellSize = s / 10;
    var pillarSize = 2 * cellSize; // 2 sub-cells wide
    var baseY = layer * ph + CONFIG.RPH / 2;
    var pos = this._subToWorld(gx, gz, sx, sz, 2, 2);
    /* Build a pillar: a box sized to 2x2 sub-cells */
    var geo = new THREE.BoxGeometry(pillarSize * 0.8, ph, pillarSize * 0.8);
    var mat = new THREE.MeshLambertMaterial({ color: 0x6B4F12 });
    var m = new THREE.Mesh(geo, mat); m.castShadow = true; m.receiveShadow = true;
    m.position.set(pos.x, baseY + ph / 2, pos.z);
    this.g.add(m);
    /* Add cross braces for visual detail */
    var braceGeo = new THREE.BoxGeometry(0.08, 0.08, pillarSize * 0.6);
    var braceMat = new THREE.MeshLambertMaterial({ color: 0x5A3E10 });
    var b1 = new THREE.Mesh(braceGeo, braceMat);
    b1.position.y = ph * 0.2; b1.rotation.y = Math.PI / 4; m.add(b1);
    var b2 = new THREE.Mesh(braceGeo.clone(), braceMat.clone());
    b2.position.y = -ph * 0.2; b2.rotation.y = -Math.PI / 4; m.add(b2);
    this.pillars.push({ gx: gx, gz: gz, sx: sx, sz: sz, layer: layer, mesh: m });
    this._subgridMark(this.pillarOcc, gx, gz, layer, sx, sz, 2, 2);
    return true;
  }
  /* Add a storage box at sub-grid position. Box is 3x3 sub-cells. */
  addStorage(gx, gz, layer, sx, sz) {
    layer = layer || 0;
    sx = (sx !== undefined) ? sx : 3; // default near center
    sz = (sz !== undefined) ? sz : 3;
    /* Bounds check: 3x3 must fit in 0..9 */
    if (sx < 0 || sx > 7 || sz < 0 || sz > 7) return false;
    /* Check base plank exists */
    if (layer === 0) { if (!this.occ.has(gx + ',' + gz)) return false; }
    else { if (!this.upperOcc.has(gx + ',' + gz + ',' + layer)) return false; }
    /* Check sub-grid is free */
    if (!this._subgridFreeAll(gx, gz, layer, sx, sz, 3, 3)) return false;
    var s = CONFIG.RPS, cellSize = s / 10;
    var boxSize = 3 * cellSize;
    var pos = this._subToWorld(gx, gz, sx, sz, 3, 3);
    var baseY = layer === 0 ? CONFIG.RPH / 2 : layer * CONFIG.PILLAR_H + CONFIG.RPH / 2;
    /* Build box mesh */
    var geo = new THREE.BoxGeometry(boxSize * 0.85, boxSize * 0.85, boxSize * 0.85);
    var mat = new THREE.MeshLambertMaterial({ color: 0x6B4F12 });
    var m = new THREE.Mesh(geo, mat); m.castShadow = true; m.receiveShadow = true;
    m.position.set(pos.x, baseY + boxSize * 0.85 / 2, pos.z);
    this.g.add(m);
    /* Add lid detail */
    var lidGeo = new THREE.BoxGeometry(boxSize * 0.88, 0.04, boxSize * 0.88);
    var lidMat = new THREE.MeshLambertMaterial({ color: 0x8B6914 });
    var lid = new THREE.Mesh(lidGeo, lidMat);
    lid.position.y = boxSize * 0.85 / 2 + 0.02; m.add(lid);
    /* Metal clasp */
    var claspGeo = new THREE.BoxGeometry(boxSize * 0.15, boxSize * 0.15, 0.03);
    var claspMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
    var clasp = new THREE.Mesh(claspGeo, claspMat);
    clasp.position.set(0, 0, boxSize * 0.85 / 2 + 0.01); m.add(clasp);
    this.storages.push({ gx: gx, gz: gz, sx: sx, sz: sz, layer: layer, mesh: m });
    this._subgridMark(this.storageOcc, gx, gz, layer, sx, sz, 3, 3);
    return true;
  }
  /* Add stairs at grid position connecting layer to layer+1 */
  addStairs(gx, gz, layer) {
    layer = layer || 0;
    var sk = gx + ',' + gz + ',' + layer;
    if (this.stairOcc.has(sk)) return false;
    /* Must have base plank or upper plank at this position */
    if (layer === 0) { if (!this.occ.has(gx + ',' + gz)) return false; }
    else { if (!this.upperOcc.has(gx + ',' + gz + ',' + layer)) return false; }
    var s = CONFIG.RPS, ph = CONFIG.PILLAR_H;
    var baseY = layer * ph + CONFIG.RPH / 2;
    /* Build stairs as a series of steps */
    var stairGroup = new THREE.Group();
    var stepCount = 6;
    var stepH = ph / stepCount;
    var stepD = (s * 0.8) / stepCount;
    var stepMat = new THREE.MeshLambertMaterial({ color: 0x8B6914 });
    for (var i = 0; i < stepCount; i++) {
      var stepGeo = new THREE.BoxGeometry(s * 0.6, 0.08, stepD * 0.9);
      var step = new THREE.Mesh(stepGeo, stepMat.clone());
      step.position.set(0, i * stepH + stepH / 2, -s * 0.4 + i * stepD + stepD / 2);
      step.castShadow = true; step.receiveShadow = true;
      stairGroup.add(step);
    }
    /* Side rails */
    var railGeo = new THREE.BoxGeometry(0.06, ph + 0.3, 0.06);
    var railMat = new THREE.MeshLambertMaterial({ color: 0x6B4F12 });
    var railL = new THREE.Mesh(railGeo, railMat);
    railL.position.set(-s * 0.3, ph / 2, 0); stairGroup.add(railL);
    var railR = new THREE.Mesh(railGeo.clone(), railMat.clone());
    railR.position.set(s * 0.3, ph / 2, 0); stairGroup.add(railR);
    /* Handrail diagonal */
    var hrGeo = new THREE.BoxGeometry(0.04, 0.04, Math.sqrt(ph * ph + s * s * 0.64) * 0.85);
    var hrMat = new THREE.MeshLambertMaterial({ color: 0x5A3E10 });
    var angle = Math.atan2(ph, s * 0.8);
    var hrL = new THREE.Mesh(hrGeo, hrMat);
    hrL.position.set(-s * 0.3, ph / 2 + 0.15, 0); hrL.rotation.x = -angle; stairGroup.add(hrL);
    var hrR = new THREE.Mesh(hrGeo.clone(), hrMat.clone());
    hrR.position.set(s * 0.3, ph / 2 + 0.15, 0); hrR.rotation.x = -angle; stairGroup.add(hrR);
    stairGroup.position.set(gx * s, baseY, gz * s);
    this.g.add(stairGroup);
    this.stairs.push({ x: gx, z: gz, layer: layer, mesh: stairGroup });
    this.stairOcc.add(sk);
    return true;
  }
  /* Check if there's any pillar on a given plank at the specified layer */
  _hasPillarOnPlank(gx, gz, layer) {
    var key = gx + ',' + gz + ',' + layer;
    return this.pillarOcc.has(key) && this.pillarOcc.get(key).size > 0;
  }
  /* Add an upper plank at grid position on given layer (1+) */
  addUpperPlank(gx, gz, layer) {
    layer = layer || 1;
    var uk = gx + ',' + gz + ',' + layer;
    if (this.upperOcc.has(uk)) return false;
    /* Must have a pillar below this position at layer-1 to support it,
     * or be adjacent (4-connected) to an existing upper plank on the same layer */
    var hasPillarBelow = this._hasPillarOnPlank(gx, gz, layer - 1);
    var hasAdjacentUpper = false;
    var nb = [[gx+1,gz],[gx-1,gz],[gx,gz+1],[gx,gz-1]];
    for (var i = 0; i < nb.length; i++) {
      if (this.upperOcc.has(nb[i][0] + ',' + nb[i][1] + ',' + layer)) { hasAdjacentUpper = true; break; }
    }
    if (!hasPillarBelow && !hasAdjacentUpper) return false;
    var ph = CONFIG.PILLAR_H;
    var y = layer * ph;
    var m = this._createPlankMesh(gx, gz, y);
    this.upperPlanks.push({ x: gx, z: gz, layer: layer, mesh: m });
    this.upperOcc.add(uk);
    return true;
  }
  /* Get all available neighbor slots for ground expansion */
  getExpandSlots() {
    var sl = [], ch = new Set();
    for (var p = 0; p < this.planks.length; p++) { var pl = this.planks[p];
      var nb = [{ x: pl.x + 1, z: pl.z }, { x: pl.x - 1, z: pl.z }, { x: pl.x, z: pl.z + 1 }, { x: pl.x, z: pl.z - 1 }];
      for (var n = 0; n < nb.length; n++) { var k = nb[n].x + ',' + nb[n].z;
        if (!this.occ.has(k) && !ch.has(k)) { sl.push(nb[n]); ch.add(k); } } }
    return sl;
  }
  /* Get sub-grid slots where pillars (2x2) can be placed */
  getPillarSlots(layer) {
    layer = layer || 0;
    var sl = [];
    var srcPlanks = layer === 0 ? this.planks : this.upperPlanks.filter(function(p) { return p.layer === layer; });
    for (var i = 0; i < srcPlanks.length; i++) {
      var p = srcPlanks[i];
      var gx = layer === 0 ? p.x : p.x;
      var gz = layer === 0 ? p.z : p.z;
      /* Skip planks that have stairs (stairs occupy the whole plank) */
      if (this.stairOcc.has(gx + ',' + gz + ',' + layer)) continue;
      /* Scan sub-grid for 2x2 positions that fit */
      for (var sx = 0; sx <= 8; sx += 2) {
        for (var sz = 0; sz <= 8; sz += 2) {
          if (this._subgridFreeAll(gx, gz, layer, sx, sz, 2, 2)) {
            sl.push({ x: gx, z: gz, sx: sx, sz: sz, layer: layer });
          }
        }
      }
    }
    return sl;
  }
  /* Get sub-grid slots where storage boxes (3x3) can be placed.
   * Step by 3 to align boxes in a grid pattern and limit slot count. */
  getStorageSlots(layer) {
    layer = layer || 0;
    var sl = [];
    var srcPlanks = layer === 0 ? this.planks : this.upperPlanks.filter(function(p) { return p.layer === layer; });
    for (var i = 0; i < srcPlanks.length; i++) {
      var p = srcPlanks[i];
      var gx = layer === 0 ? p.x : p.x;
      var gz = layer === 0 ? p.z : p.z;
      if (this.stairOcc.has(gx + ',' + gz + ',' + layer)) continue;
      /* Scan sub-grid for 3x3 positions, stepping by 3 for grid alignment */
      for (var sx = 0; sx <= 7; sx += 3) {
        for (var sz = 0; sz <= 7; sz += 3) {
          if (this._subgridFreeAll(gx, gz, layer, sx, sz, 3, 3)) {
            sl.push({ x: gx, z: gz, sx: sx, sz: sz, layer: layer });
          }
        }
      }
    }
    return sl;
  }
  /* Get plank slots that can have stairs (planks without stairs) */
  getStairsSlots(layer) {
    layer = layer || 0;
    var sl = [];
    var srcPlanks = layer === 0 ? this.planks : this.upperPlanks.filter(function(p) { return p.layer === layer; });
    for (var i = 0; i < srcPlanks.length; i++) {
      var p = srcPlanks[i];
      var sk = p.x + ',' + p.z + ',' + layer;
      if (!this.stairOcc.has(sk)) {
        sl.push({ x: p.x, z: p.z, layer: layer });
      }
    }
    return sl;
  }
  /* Get slots where upper planks can be placed (above pillars or adjacent to existing upper planks) */
  getUpperPlankSlots(layer) {
    layer = layer || 1;
    var sl = [], ch = new Set();
    /* Positions above planks that have pillars on layer-1 */
    for (var i = 0; i < this.pillars.length; i++) {
      var p = this.pillars[i];
      if (p.layer === layer - 1) {
        var uk = p.gx + ',' + p.gz + ',' + layer;
        if (!this.upperOcc.has(uk) && !ch.has(uk)) { sl.push({ x: p.gx, z: p.gz, layer: layer }); ch.add(uk); }
      }
    }
    /* Positions adjacent to existing upper planks on this layer */
    var existing = this.upperPlanks.filter(function(u) { return u.layer === layer; });
    for (var i = 0; i < existing.length; i++) {
      var u = existing[i];
      var nb = [{ x: u.x+1, z: u.z }, { x: u.x-1, z: u.z }, { x: u.x, z: u.z+1 }, { x: u.x, z: u.z-1 }];
      for (var n = 0; n < nb.length; n++) {
        var uk = nb[n].x + ',' + nb[n].z + ',' + layer;
        if (!this.upperOcc.has(uk) && !ch.has(uk)) {
          /* Must have a pillar below OR be adjacent to an existing upper plank */
          sl.push({ x: nb[n].x, z: nb[n].z, layer: layer }); ch.add(uk);
        }
      }
    }
    return sl;
  }
  /* Show highlight meshes at available slots */
  showSlots() {
    this.hideSlots();
    this._slotMeshes = [];
    var slots = this.getExpandSlots(), s = CONFIG.RPS;
    for (var i = 0; i < slots.length; i++) {
      var geo = new THREE.BoxGeometry(s - 0.1, 0.05, s - 0.1);
      var mat = new THREE.MeshBasicMaterial({ color: 0x44ff88, transparent: true, opacity: 0.35 });
      var m = new THREE.Mesh(geo, mat);
      m.position.set(slots[i].x * s, CONFIG.RPH / 2 + 0.05, slots[i].z * s);
      m.userData = { gx: slots[i].x, gz: slots[i].z };
      this.g.add(m);
      this._slotMeshes.push(m);
    }
  }
  /* Show highlight meshes on existing planks (for placing items on raft - currently unused, kept for compatibility) */
  showPlankSlots() {
    this.hideSlots();
    this._slotMeshes = [];
    var s = CONFIG.RPS;
    for (var i = 0; i < this.planks.length; i++) {
      var pl = this.planks[i];
      var geo = new THREE.BoxGeometry(s - 0.1, 0.05, s - 0.1);
      var mat = new THREE.MeshBasicMaterial({ color: 0x44aaff, transparent: true, opacity: 0.35 });
      var m = new THREE.Mesh(geo, mat);
      m.position.set(pl.x * s, CONFIG.RPH / 2 + 0.05, pl.z * s);
      m.userData = { gx: pl.x, gz: pl.z };
      this.g.add(m);
      this._slotMeshes.push(m);
    }
  }
  /* Show pillar placement slots (sub-grid 2x2) - only show bottom preview */
  showPillarSlots(layer) {
    this.hideSlots();
    this._slotMeshes = [];
    var slots = this.getPillarSlots(layer), s = CONFIG.RPS, ph = CONFIG.PILLAR_H;
    var cellSize = s / 10;
    var pillarVisSize = 2 * cellSize;
    var baseY = layer * ph + CONFIG.RPH / 2;
    var previewHeight = 0.3; // Only show bottom of pillar
    for (var i = 0; i < slots.length; i++) {
      var pos = this._subToWorld(slots[i].x, slots[i].z, slots[i].sx, slots[i].sz, 2, 2);
      var geo = new THREE.BoxGeometry(pillarVisSize * 0.85, previewHeight, pillarVisSize * 0.85);
      var mat = new THREE.MeshBasicMaterial({ color: 0xffaa44, transparent: true, opacity: 0.5 });
      var m = new THREE.Mesh(geo, mat);
      m.position.set(pos.x, baseY + previewHeight / 2, pos.z);
      m.userData = { gx: slots[i].x, gz: slots[i].z, sx: slots[i].sx, sz: slots[i].sz, layer: layer };
      this.g.add(m);
      this._slotMeshes.push(m);
    }
  }
  /* Show storage box placement slots (sub-grid 3x3) */
  showStorageSlots(layer) {
    this.hideSlots();
    this._slotMeshes = [];
    var slots = this.getStorageSlots(layer), s = CONFIG.RPS;
    var cellSize = s / 10;
    var boxVisSize = 3 * cellSize;
    var baseY = layer === 0 ? CONFIG.RPH / 2 : layer * CONFIG.PILLAR_H + CONFIG.RPH / 2;
    for (var i = 0; i < slots.length; i++) {
      var pos = this._subToWorld(slots[i].x, slots[i].z, slots[i].sx, slots[i].sz, 3, 3);
      var geo = new THREE.BoxGeometry(boxVisSize * 0.85, boxVisSize * 0.6, boxVisSize * 0.85);
      var mat = new THREE.MeshBasicMaterial({ color: 0xaa88ff, transparent: true, opacity: 0.3 });
      var m = new THREE.Mesh(geo, mat);
      m.position.set(pos.x, baseY + boxVisSize * 0.3, pos.z);
      m.userData = { gx: slots[i].x, gz: slots[i].z, sx: slots[i].sx, sz: slots[i].sz, layer: layer };
      this.g.add(m);
      this._slotMeshes.push(m);
    }
  }
  /* Show stairs placement slots */
  showStairsSlots(layer) {
    this.hideSlots();
    this._slotMeshes = [];
    var slots = this.getStairsSlots(layer), s = CONFIG.RPS, ph = CONFIG.PILLAR_H;
    var baseY = layer * ph + CONFIG.RPH / 2;
    for (var i = 0; i < slots.length; i++) {
      var geo = new THREE.BoxGeometry(s * 0.7, ph * 0.5, s * 0.7);
      var mat = new THREE.MeshBasicMaterial({ color: 0x44ffaa, transparent: true, opacity: 0.3 });
      var m = new THREE.Mesh(geo, mat);
      m.position.set(slots[i].x * s, baseY + ph * 0.25, slots[i].z * s);
      m.userData = { gx: slots[i].x, gz: slots[i].z, layer: layer };
      this.g.add(m);
      this._slotMeshes.push(m);
    }
  }
  /* Show upper plank placement slots */
  showUpperPlankSlots(layer) {
    this.hideSlots();
    this._slotMeshes = [];
    var slots = this.getUpperPlankSlots(layer), s = CONFIG.RPS, ph = CONFIG.PILLAR_H;
    var y = layer * ph;
    for (var i = 0; i < slots.length; i++) {
      var geo = new THREE.BoxGeometry(s - 0.1, 0.05, s - 0.1);
      var mat = new THREE.MeshBasicMaterial({ color: 0x44ff88, transparent: true, opacity: 0.35 });
      var m = new THREE.Mesh(geo, mat);
      m.position.set(slots[i].x * s, y + 0.05, slots[i].z * s);
      m.userData = { gx: slots[i].x, gz: slots[i].z, layer: layer };
      this.g.add(m);
      this._slotMeshes.push(m);
    }
  }
  /* Hide slot highlights */
  hideSlots() {
    if (!this._slotMeshes) return;
    for (var i = 0; i < this._slotMeshes.length; i++) {
      this.g.remove(this._slotMeshes[i]);
      this._slotMeshes[i].geometry.dispose();
      this._slotMeshes[i].material.dispose();
    }
    this._slotMeshes = [];
  }
  /* Remove a ground plank at grid position. Cannot remove the last plank. */
  removePlank(gx, gz) {
    if (this.planks.length <= 1) return false; // keep at least one plank
    var k = gx + ',' + gz;
    if (!this.occ.has(k)) return false;
    /* Check if any pillar, stairs or storage sits on this plank at layer 0 */
    if (this._hasPillarOnPlank(gx, gz, 0)) return false;
    if (this.stairOcc.has(gx + ',' + gz + ',0')) return false;
    var storageKey = gx + ',' + gz + ',0';
    if (this.storageOcc.has(storageKey) && this.storageOcc.get(storageKey).size > 0) return false;
    /* Check if any upper plank depends on pillar on this plank (already blocked above) */
    for (var i = 0; i < this.planks.length; i++) {
      if (this.planks[i].x === gx && this.planks[i].z === gz) {
        this.g.remove(this.planks[i].mesh);
        this.planks[i].mesh.traverse(function(child) {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        this.planks.splice(i, 1);
        break;
      }
    }
    this.occ.delete(k);
    return true;
  }
  /* Remove a pillar at given position */
  removePillar(gx, gz, layer, sx, sz) {
    for (var i = 0; i < this.pillars.length; i++) {
      var p = this.pillars[i];
      if (p.gx === gx && p.gz === gz && p.layer === layer && p.sx === sx && p.sz === sz) {
        this.g.remove(p.mesh);
        p.mesh.traverse(function(child) {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        this.pillars.splice(i, 1);
        /* Unmark sub-grid cells */
        var key = gx + ',' + gz + ',' + layer;
        var cells = this.pillarOcc.get(key);
        if (cells) {
          for (var dx = 0; dx < 2; dx++) {
            for (var dz = 0; dz < 2; dz++) {
              cells.delete((sx + dx) + ',' + (sz + dz));
            }
          }
          if (cells.size === 0) this.pillarOcc.delete(key);
        }
        return true;
      }
    }
    return false;
  }
  /* Remove stairs at given position */
  removeStairs(gx, gz, layer) {
    var sk = gx + ',' + gz + ',' + layer;
    if (!this.stairOcc.has(sk)) return false;
    for (var i = 0; i < this.stairs.length; i++) {
      var s = this.stairs[i];
      if (s.x === gx && s.z === gz && s.layer === layer) {
        this.g.remove(s.mesh);
        /* Stairs are a group, dispose children */
        s.mesh.traverse(function(child) {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        this.stairs.splice(i, 1);
        break;
      }
    }
    this.stairOcc.delete(sk);
    return true;
  }
  /* Remove an upper plank at given position */
  removeUpperPlank(gx, gz, layer) {
    var uk = gx + ',' + gz + ',' + layer;
    if (!this.upperOcc.has(uk)) return false;
    /* Check if anything is built on this upper plank */
    if (this._hasPillarOnPlank(gx, gz, layer)) return false;
    if (this.stairOcc.has(gx + ',' + gz + ',' + layer)) return false;
    var storageKey = gx + ',' + gz + ',' + layer;
    if (this.storageOcc.has(storageKey) && this.storageOcc.get(storageKey).size > 0) return false;
    for (var i = 0; i < this.upperPlanks.length; i++) {
      var u = this.upperPlanks[i];
      if (u.x === gx && u.z === gz && u.layer === layer) {
        this.g.remove(u.mesh);
        u.mesh.traverse(function(child) {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        this.upperPlanks.splice(i, 1);
        break;
      }
    }
    this.upperOcc.delete(uk);
    return true;
  }
  /* Remove a storage box at given position */
  removeStorage(gx, gz, layer, sx, sz) {
    for (var i = 0; i < this.storages.length; i++) {
      var st = this.storages[i];
      if (st.gx === gx && st.gz === gz && st.layer === layer && st.sx === sx && st.sz === sz) {
        this.g.remove(st.mesh);
        st.mesh.traverse(function(child) {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
        this.storages.splice(i, 1);
        /* Unmark sub-grid cells */
        var key = gx + ',' + gz + ',' + layer;
        var cells = this.storageOcc.get(key);
        if (cells) {
          for (var dx = 0; dx < 3; dx++) {
            for (var dz = 0; dz < 3; dz++) {
              cells.delete((sx + dx) + ',' + (sz + dz));
            }
          }
          if (cells.size === 0) this.storageOcc.delete(key);
        }
        return true;
      }
    }
    return false;
  }
  /* Show demolish highlights for a specific type. Returns meshes for raycasting.
   * Each mesh has userData describing what to demolish. */
  showDemolishTargets(type) {
    this.hideSlots();
    this._slotMeshes = [];
    var s = CONFIG.RPS;
    if (type === 'plank') {
      for (var i = 0; i < this.planks.length; i++) {
        if (this.planks.length <= 1) break; // can't remove last plank
        var p = this.planks[i];
        /* Skip if stuff is built on it */
        if (this._hasPillarOnPlank(p.x, p.z, 0)) continue;
        if (this.stairOcc.has(p.x + ',' + p.z + ',0')) continue;
        var stKey = p.x + ',' + p.z + ',0';
        if (this.storageOcc.has(stKey) && this.storageOcc.get(stKey).size > 0) continue;
        var geo = new THREE.BoxGeometry(s - 0.1, 0.08, s - 0.1);
        var mat = new THREE.MeshBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.45 });
        var m = new THREE.Mesh(geo, mat);
        m.position.set(p.x * s, CONFIG.RPH / 2 + 0.08, p.z * s);
        m.userData = { demolishType: 'plank', gx: p.x, gz: p.z };
        this.g.add(m);
        this._slotMeshes.push(m);
      }
    } else if (type === 'pillar') {
      var cellSize = s / 10;
      var pillarVisSize = 2 * cellSize;
      for (var i = 0; i < this.pillars.length; i++) {
        var p = this.pillars[i];
        var pos = this._subToWorld(p.gx, p.gz, p.sx, p.sz, 2, 2);
        var baseY = p.layer * CONFIG.PILLAR_H + CONFIG.RPH / 2;
        var geo = new THREE.BoxGeometry(pillarVisSize * 0.85, CONFIG.PILLAR_H * 0.9, pillarVisSize * 0.85);
        var mat = new THREE.MeshBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.35 });
        var m = new THREE.Mesh(geo, mat);
        m.position.set(pos.x, baseY + CONFIG.PILLAR_H / 2, pos.z);
        m.userData = { demolishType: 'pillar', gx: p.gx, gz: p.gz, layer: p.layer, sx: p.sx, sz: p.sz };
        this.g.add(m);
        this._slotMeshes.push(m);
      }
    } else if (type === 'stairs') {
      for (var i = 0; i < this.stairs.length; i++) {
        var st = this.stairs[i];
        var baseY = st.layer * CONFIG.PILLAR_H + CONFIG.RPH / 2;
        var geo = new THREE.BoxGeometry(s * 0.7, CONFIG.PILLAR_H * 0.5, s * 0.7);
        var mat = new THREE.MeshBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.35 });
        var m = new THREE.Mesh(geo, mat);
        m.position.set(st.x * s, baseY + CONFIG.PILLAR_H * 0.25, st.z * s);
        m.userData = { demolishType: 'stairs', gx: st.x, gz: st.z, layer: st.layer };
        this.g.add(m);
        this._slotMeshes.push(m);
      }
    } else if (type === 'upper_plank') {
      for (var i = 0; i < this.upperPlanks.length; i++) {
        var u = this.upperPlanks[i];
        /* Skip if stuff is built on it */
        if (this._hasPillarOnPlank(u.x, u.z, u.layer)) continue;
        if (this.stairOcc.has(u.x + ',' + u.z + ',' + u.layer)) continue;
        var stKey = u.x + ',' + u.z + ',' + u.layer;
        if (this.storageOcc.has(stKey) && this.storageOcc.get(stKey).size > 0) continue;
        var y = u.layer * CONFIG.PILLAR_H;
        var geo = new THREE.BoxGeometry(s - 0.1, 0.08, s - 0.1);
        var mat = new THREE.MeshBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.45 });
        var m = new THREE.Mesh(geo, mat);
        m.position.set(u.x * s, y + 0.08, u.z * s);
        m.userData = { demolishType: 'upper_plank', gx: u.x, gz: u.z, layer: u.layer };
        this.g.add(m);
        this._slotMeshes.push(m);
      }
    } else if (type === 'storage') {
      var cellSize = s / 10;
      var boxVisSize = 3 * cellSize;
      for (var i = 0; i < this.storages.length; i++) {
        var st = this.storages[i];
        var pos = this._subToWorld(st.gx, st.gz, st.sx, st.sz, 3, 3);
        var baseY = st.layer === 0 ? CONFIG.RPH / 2 : st.layer * CONFIG.PILLAR_H + CONFIG.RPH / 2;
        var geo = new THREE.BoxGeometry(boxVisSize * 0.88, boxVisSize * 0.88, boxVisSize * 0.88);
        var mat = new THREE.MeshBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.35 });
        var m = new THREE.Mesh(geo, mat);
        m.position.set(pos.x, baseY + boxVisSize * 0.88 / 2, pos.z);
        m.userData = { demolishType: 'storage', gx: st.gx, gz: st.gz, layer: st.layer, sx: st.sx, sz: st.sz };
        this.g.add(m);
        this._slotMeshes.push(m);
      }
    }
  }
  /* Get slot meshes for raycasting */
  getSlotMeshes() { return this._slotMeshes || []; }
  /* Get the floor height at a local position (returns the highest walkable surface) */
  getFloorY(lx, lz) {
    var s = CONFIG.RPS, half = s / 2, ph = CONFIG.PILLAR_H;
    var bestY = -Infinity;
    /* Check ground planks */
    for (var i = 0; i < this.planks.length; i++) {
      var p = this.planks[i];
      var px = p.x * s, pz = p.z * s;
      if (lx >= px - half && lx <= px + half && lz >= pz - half && lz <= pz + half) {
        bestY = Math.max(bestY, CONFIG.RPH / 2);
      }
    }
    /* Check upper planks */
    for (var i = 0; i < this.upperPlanks.length; i++) {
      var u = this.upperPlanks[i];
      var px = u.x * s, pz = u.z * s;
      if (lx >= px - half && lx <= px + half && lz >= pz - half && lz <= pz + half) {
        bestY = Math.max(bestY, u.layer * ph + CONFIG.RPH / 2);
      }
    }
    /* Check stairs - allow walking on stairs (interpolated height) */
    for (var i = 0; i < this.stairs.length; i++) {
      var st = this.stairs[i];
      var px = st.x * s, pz = st.z * s;
      if (lx >= px - half && lx <= px + half && lz >= pz - half && lz <= pz + half) {
        /* Interpolate stair height based on Z position within the cell */
        var localZ = (lz - pz) / s + 0.5; // 0..1 within cell
        var stairY = st.layer * ph + CONFIG.RPH / 2 + localZ * ph;
        bestY = Math.max(bestY, stairY);
      }
    }
    return bestY;
  }
  /* Get floor height at position, constrained to surfaces near the current height.
   * This prevents auto-jumping to upper floors when upper planks are built above. */
  getFloorYNear(lx, lz, currentY) {
    var s = CONFIG.RPS, half = s / 2, ph = CONFIG.PILLAR_H;
    var maxStep = ph * 0.6;
    var bestY = -Infinity;
    /* Check ground planks */
    for (var i = 0; i < this.planks.length; i++) {
      var p = this.planks[i];
      var px = p.x * s, pz = p.z * s;
      if (lx >= px - half && lx <= px + half && lz >= pz - half && lz <= pz + half) {
        var y = CONFIG.RPH / 2;
        if (Math.abs(y - currentY) < maxStep) bestY = Math.max(bestY, y);
      }
    }
    /* Check upper planks */
    for (var i = 0; i < this.upperPlanks.length; i++) {
      var u = this.upperPlanks[i];
      var px = u.x * s, pz = u.z * s;
      if (lx >= px - half && lx <= px + half && lz >= pz - half && lz <= pz + half) {
        var y = u.layer * ph + CONFIG.RPH / 2;
        if (Math.abs(y - currentY) < maxStep) bestY = Math.max(bestY, y);
      }
    }
    /* Check stairs */
    for (var i = 0; i < this.stairs.length; i++) {
      var st = this.stairs[i];
      var px = st.x * s, pz = st.z * s;
      if (lx >= px - half && lx <= px + half && lz >= pz - half && lz <= pz + half) {
        var localZ = (lz - pz) / s + 0.5;
        var stairY = st.layer * ph + CONFIG.RPH / 2 + localZ * ph;
        if (Math.abs(stairY - currentY) < maxStep) bestY = Math.max(bestY, stairY);
      }
    }
    return bestY;
  }
  /* Check if position is walkable at a given target height */
  isWalkable(lx, lz, currentY) {
    var floorY = this.getFloorYNear(lx, lz, currentY);
    if (floorY === -Infinity) return false;
    /* Allow stepping up/down within reasonable range */
    var maxStep = CONFIG.PILLAR_H * 0.6;
    return Math.abs(floorY - currentY) < maxStep;
  }
  /* Set observe mode: make structures above playerLayer semi-transparent */
  setObserveMode(enabled, playerLayer) {
    var ph = CONFIG.PILLAR_H;
    /* Ground planks are always layer 0 - always opaque */
    for (var i = 0; i < this.planks.length; i++) {
      this.planks[i].mesh.traverse(function(child) {
        if (child.material) { child.material.transparent = false; child.material.opacity = 1.0; }
      });
    }
    /* Pillars */
    for (var i = 0; i < this.pillars.length; i++) {
      var p = this.pillars[i];
      var above = enabled && p.layer > playerLayer;
      p.mesh.traverse(function(child) {
        if (child.material) { child.material.transparent = above; child.material.opacity = above ? 0.2 : 1.0; }
      });
    }
    /* Stairs */
    for (var i = 0; i < this.stairs.length; i++) {
      var st = this.stairs[i];
      var above = enabled && st.layer > playerLayer;
      st.mesh.traverse(function(child) {
        if (child.material) { child.material.transparent = above; child.material.opacity = above ? 0.2 : 1.0; }
      });
    }
    /* Upper planks */
    for (var i = 0; i < this.upperPlanks.length; i++) {
      var u = this.upperPlanks[i];
      var above = enabled && u.layer > playerLayer;
      u.mesh.traverse(function(child) {
        if (child.material) { child.material.transparent = above; child.material.opacity = above ? 0.2 : 1.0; }
      });
    }
    /* Storage boxes */
    for (var i = 0; i < this.storages.length; i++) {
      var st = this.storages[i];
      var above = enabled && st.layer > playerLayer;
      st.mesh.traverse(function(child) {
        if (child.material) { child.material.transparent = above; child.material.opacity = above ? 0.2 : 1.0; }
      });
    }
  }
  /* Physics update */
  update(dt) { this.vel.multiplyScalar(Math.pow(CONFIG.RD, dt * 60));
    if (this.vel.lengthSq() < 0.000001) this.vel.set(0, 0, 0);
    this.g.position.x += this.vel.x * dt; this.g.position.z += this.vel.z * dt;
    this.g.position.y = CONFIG.RY; }
  push(f) { this.vel.add(f); }
}

/* ===== Player - third person camera with visible character (å°äºº) ===== */
class Player {
  constructor(cam, raft, inp, scene) {
    this.cam = cam; this.raft = raft; this.inp = inp;
    this.camYaw = 0; this.camPitch = 0.5; // Camera orbit angles
    this.camDist = CONFIG.CAM_DIST; // Current zoom distance (adjustable via scroll wheel)
    this.charYaw = 0; // Character facing direction
    /* Local offset of character on the raft (relative to raft group origin) */
    this.localX = 0; this.localZ = 0;
    this.walking = false; this.walkTimer = 0;
    /* Reusable objects to avoid per-frame allocation */
    this._fwdVec = new THREE.Vector3(); this._fwdEuler = new THREE.Euler();
    this._lookVec = new THREE.Vector3(); this._charPosVec = new THREE.Vector3();
    /* Build the character model (å°äºº) */
    this.model = this._buildCharacter();
    scene.add(this.model);
  }
  /* Build a simple humanoid character from boxes */
  _buildCharacter() {
    var g = new THREE.Group();
    var skinColor = 0xFFDBAC, shirtColor = 0x3377CC, pantsColor = 0x445566, shoeColor = 0x333333, hairColor = 0x332211;
    /* Head */
    var headGeo = new THREE.BoxGeometry(0.35, 0.35, 0.35);
    var headMat = new THREE.MeshLambertMaterial({ color: skinColor });
    this.head = new THREE.Mesh(headGeo, headMat);
    this.head.position.y = 1.55; this.head.castShadow = true; g.add(this.head);
    /* Hair */
    var hairGeo = new THREE.BoxGeometry(0.38, 0.15, 0.38);
    var hairMat = new THREE.MeshLambertMaterial({ color: hairColor });
    var hair = new THREE.Mesh(hairGeo, hairMat);
    hair.position.y = 1.75; hair.castShadow = true; g.add(hair);
    /* Eyes */
    var eyeGeo = new THREE.BoxGeometry(0.06, 0.06, 0.04);
    var eyeMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
    var eyeL = new THREE.Mesh(eyeGeo, eyeMat); eyeL.position.set(-0.08, 1.57, 0.17); g.add(eyeL);
    var eyeR = new THREE.Mesh(eyeGeo, eyeMat.clone()); eyeR.position.set(0.08, 1.57, 0.17); g.add(eyeR);
    /* Body/torso */
    var bodyGeo = new THREE.BoxGeometry(0.4, 0.5, 0.25);
    var bodyMat = new THREE.MeshLambertMaterial({ color: shirtColor });
    this.body = new THREE.Mesh(bodyGeo, bodyMat);
    this.body.position.y = 1.1; this.body.castShadow = true; g.add(this.body);
    /* Left arm */
    var armGeo = new THREE.BoxGeometry(0.15, 0.45, 0.15);
    var armMat = new THREE.MeshLambertMaterial({ color: shirtColor });
    this.armL = new THREE.Mesh(armGeo, armMat);
    this.armL.position.set(-0.28, 1.1, 0); this.armL.castShadow = true; g.add(this.armL);
    /* Right arm */
    this.armR = new THREE.Mesh(armGeo.clone(), armMat.clone());
    this.armR.position.set(0.28, 1.1, 0); this.armR.castShadow = true; g.add(this.armR);
    /* Left leg */
    var legGeo = new THREE.BoxGeometry(0.16, 0.45, 0.16);
    var legMat = new THREE.MeshLambertMaterial({ color: pantsColor });
    this.legL = new THREE.Mesh(legGeo, legMat);
    this.legL.position.set(-0.1, 0.55, 0); this.legL.castShadow = true; g.add(this.legL);
    /* Right leg */
    this.legR = new THREE.Mesh(legGeo.clone(), legMat.clone());
    this.legR.position.set(0.1, 0.55, 0); this.legR.castShadow = true; g.add(this.legR);
    /* Shoes */
    var shoeGeo = new THREE.BoxGeometry(0.17, 0.08, 0.22);
    var shoeMat = new THREE.MeshLambertMaterial({ color: shoeColor });
    var shoeL = new THREE.Mesh(shoeGeo, shoeMat); shoeL.position.set(-0.1, 0.3, 0.03); shoeL.castShadow = true; g.add(shoeL);
    var shoeR = new THREE.Mesh(shoeGeo.clone(), shoeMat.clone()); shoeR.position.set(0.1, 0.3, 0.03); shoeR.castShadow = true; g.add(shoeR);
    g.scale.set(0.8, 0.8, 0.8);
    return g;
  }
  /* Track the current floor height to avoid auto-snapping to upper floors */
  _currentFloorY() {
    /* Use getFloorYNear to stay on the current level */
    var nearY = this.raft.getFloorYNear(this.localX, this.localZ, this._lastFloorY || CONFIG.RPH / 2);
    if (nearY === -Infinity) {
      /* Fallback: use absolute getFloorY (e.g., at game start) */
      nearY = this.raft.getFloorY(this.localX, this.localZ);
    }
    if (nearY !== -Infinity) this._lastFloorY = nearY;
    return nearY;
  }
  update(dt) {
    /* Camera orbit: right-mouse-button drag controls camera angle */
    if (this.inp.rmb && !this.inp.uiOpen) {
      this.camYaw -= this.inp.dx * CONFIG.MS;
      this.camPitch += this.inp.dy * CONFIG.MS;
      this.camPitch = Math.max(CONFIG.CAM_PITCH_MIN, Math.min(CONFIG.CAM_PITCH_MAX, this.camPitch));
    }
    /* Q/E keys: rotate camera yaw left/right */
    if (!this.inp.uiOpen) {
      if (this.inp.kd('KeyQ')) this.camYaw += CONFIG.CAM_KEY_ROTATE_SPEED * dt;
      if (this.inp.kd('KeyE')) this.camYaw -= CONFIG.CAM_KEY_ROTATE_SPEED * dt;
    }
    /* Get current floor height (single call, reused below) */
    var curFloorY = this._currentFloorY();
    if (curFloorY === -Infinity) curFloorY = CONFIG.RPH / 2;
    /* WASD: move character on the raft */
    this.walking = false;
    if (!this.inp.uiOpen) {
      var moveX = 0, moveZ = 0;
      if (this.inp.kd('KeyW')) moveZ += 1;
      if (this.inp.kd('KeyS')) moveZ -= 1;
      if (this.inp.kd('KeyA')) moveX -= 1;
      if (this.inp.kd('KeyD')) moveX += 1;
      if (moveX !== 0 || moveZ !== 0) {
        this.walking = true;
        this.walkTimer += dt * 8;
        /* Move relative to camera yaw direction - cache sin/cos */
        var sinA = Math.sin(this.camYaw), cosA = Math.cos(this.camYaw);
        var worldMoveX = moveX * cosA - moveZ * sinA;
        var worldMoveZ = -moveX * sinA - moveZ * cosA;
        var len = Math.sqrt(worldMoveX * worldMoveX + worldMoveZ * worldMoveZ);
        if (len > 0) { worldMoveX /= len; worldMoveZ /= len; }
        /* Face character in movement direction */
        this.charYaw = Math.atan2(worldMoveX, worldMoveZ);
        var speed = CONFIG.CHAR_SPEED * dt;
        var newLX = this.localX + worldMoveX * speed;
        var newLZ = this.localZ + worldMoveZ * speed;
        /* Only move if target position is walkable */
        if (this.raft.isWalkable(newLX, newLZ, curFloorY)) {
          this.localX = newLX;
          this.localZ = newLZ;
          /* Refresh floor height after movement */
          curFloorY = this._currentFloorY();
          if (curFloorY === -Infinity) curFloorY = CONFIG.RPH / 2;
        }
      }
    }
    /* Update floor tracking */
    this._lastFloorY = curFloorY;
    /* Animate walking (swing arms and legs) */
    var swing = this.walking ? Math.sin(this.walkTimer) * 0.5 : 0;
    this.armL.rotation.x = swing;
    this.armR.rotation.x = -swing;
    this.legL.rotation.x = -swing;
    this.legR.rotation.x = swing;
    /* Position character model in world space (raft position + local offset) */
    var rp = this.raft.g.position;
    var charWorldX = rp.x + this.localX;
    var charWorldZ = rp.z + this.localZ;
    var charWorldY = rp.y + curFloorY;
    this.model.position.set(charWorldX, charWorldY, charWorldZ);
    this.model.rotation.y = this.charYaw;
    /* Position camera: orbit around character - cache trig values */
    var camDist = this.camDist;
    var camH = CONFIG.CAM_HEIGHT;
    var sinYaw = Math.sin(this.camYaw), cosYaw = Math.cos(this.camYaw);
    var cosPitch = Math.cos(this.camPitch), sinPitch = Math.sin(this.camPitch);
    var camX = charWorldX + sinYaw * cosPitch * camDist;
    var camZ = charWorldZ + cosYaw * cosPitch * camDist;
    var camY = charWorldY + camH + sinPitch * camDist;
    this.cam.position.set(camX, camY, camZ);
    /* Camera looks at character upper body */
    this.cam.lookAt(charWorldX, charWorldY + 1.2, charWorldZ);
  }
  /* Adjust camera zoom distance (delta > 0 = zoom out, delta < 0 = zoom in) */
  zoom(delta) {
    this.camDist = Math.max(CONFIG.CAM_DIST_MIN, Math.min(CONFIG.CAM_DIST_MAX, this.camDist + delta * CONFIG.CAM_ZOOM_SPEED));
  }
  /* World position of the character (for tools) - uses cached floor height, reuses internal vector */
  charPos() {
    var rp = this.raft.g.position;
    var floorY = this._lastFloorY !== undefined ? this._lastFloorY : CONFIG.RPH / 2;
    this._charPosVec.set(rp.x + this.localX, rp.y + floorY + 1.2, rp.z + this.localZ);
    return this._charPosVec;
  }
  /* Get current layer the character is standing on (0 = ground, 1+ = upper floors) */
  getCurrentLayer() {
    var floorY = this._lastFloorY || CONFIG.RPH / 2;
    var layer = Math.round((floorY - CONFIG.RPH / 2) / CONFIG.PILLAR_H);
    return Math.max(0, layer);
  }
  /* Horizontal forward based on camera yaw (for paddle) */
  fwd() { this._fwdVec.set(0, 0, -1); this._fwdEuler.set(0, this.camYaw, 0, 'YXZ'); this._fwdVec.applyEuler(this._fwdEuler); this._fwdVec.y = 0; this._fwdVec.normalize(); return this._fwdVec; }
  /* Full look direction from camera (for hook) */
  look() {
    this.cam.getWorldDirection(this._lookVec);
    this._lookVec.normalize();
    return this._lookVec;
  }
}

/* ===== FloatingItem - collectible on water surface ===== */
class FloatingItem {
  constructor(sc, type, pos) { this.sc = sc; this.type = type; this.info = IT[type]; this.alive = true;
    this.driftX = (Math.random() - 0.5); this.driftZ = (Math.random() - 0.5);
    var dl = Math.sqrt(this.driftX*this.driftX + this.driftZ*this.driftZ);
    if (dl > 0) { this.driftX /= dl; this.driftZ /= dl; }
    var g = new THREE.BoxGeometry(this.info.sx, this.info.sy, this.info.sz);
    var m = new THREE.MeshLambertMaterial({ color: this.info.color });
    this.mesh = new THREE.Mesh(g, m); this.mesh.position.copy(pos); this.mesh.position.y = CONFIG.FY;
    this.mesh.castShadow = true; this.mesh.rotation.y = Math.random() * Math.PI * 2; sc.add(this.mesh); }
  update(dt, t) { if (!this.alive) return;
    var mp = this.mesh.position;
    mp.x += this.driftX * CONFIG.DS * dt; mp.z += this.driftZ * CONFIG.DS * dt;
    mp.y = CONFIG.FY + Math.sin(t * 2 + mp.x) * 0.05; this.mesh.rotation.y += dt * 0.3; }
  /* Returns the mesh position directly (no clone) - callers must not store the reference */
  pos() { return this.mesh.position; }
  die() { this.alive = false; this.sc.remove(this.mesh); this.mesh.geometry.dispose(); this.mesh.material.dispose(); }
}

/* ===== ItemSpawner - spawn and manage floating items ===== */
class ItemSpawner {
  constructor(sc, raft) { this.sc = sc; this.raft = raft; this.items = []; this.tmr = 0;
    this._spawnPos = new THREE.Vector3(); }
  update(dt, t) { this.tmr -= dt;
    if (this.tmr <= 0 && this.items.length < CONFIG.SMX) { this._sp(); this.tmr = CONFIG.SI; }
    var rp = this.raft.g.position;
    var maxDistSq = 150 * 150;
    /* Update items and compact array in-place to avoid per-frame allocation */
    var alive = 0;
    for (var i = 0; i < this.items.length; i++) {
      var it = this.items[i];
      if (!it.alive) continue;
      it.update(dt, t);
      var ip = it.mesh.position;
      var dx = ip.x - rp.x, dz = ip.z - rp.z;
      if (dx*dx + dz*dz > maxDistSq) { it.die(); continue; }
      this.items[alive++] = it;
    }
    this.items.length = alive;
  }
  _sp() { var rp = this.raft.g.position, a = Math.random() * Math.PI * 2;
    var d = CONFIG.SRN + Math.random() * (CONFIG.SRX - CONFIG.SRN);
    this._spawnPos.set(rp.x + Math.cos(a) * d, CONFIG.FY, rp.z + Math.sin(a) * d);
    var tp = Object.keys(IT), w = [35, 25, 15, 13, 8, 4], r = Math.random() * 100, s = tp[0];
    for (var i = 0; i < tp.length; i++) { r -= w[i]; if (r <= 0) { s = tp[i]; break; } }
    this.items.push(new FloatingItem(this.sc, s, this._spawnPos)); }
  get() { return this.items; }
}

/* ===== Inventory - resource tracking ===== */
class Inventory {
  constructor() {
    this.it = {}; var t = Object.keys(IT); for (var i = 0; i < t.length; i++) this.it[t[i]] = 0;
    /* Equipment slots */
    this.equippedTool = 'hook'; // 'hook' | 'fishing_rod'
    this.fishingRodCount = 0; // how many fishing rods in backpack
  }
  add(t, n) { this.it[t] += (n || 1); }
  use(t, n) { n = n || 1; if (this.it[t] >= n) { this.it[t] -= n; return true; } return false; }
  cnt(t) { return this.it[t] || 0; }
  can(cost) { var e = Object.entries(cost); for (var i = 0; i < e.length; i++) if (this.cnt(e[i][0]) < e[i][1]) return false; return true; }
  pay(cost) { if (!this.can(cost)) return false; var e = Object.entries(cost); for (var i = 0; i < e.length; i++) this.use(e[i][0], e[i][1]); return true; }
}

/* ===== Hook - grappling tool (ready->flying->pulling->ready) ===== */
class Hook {
  constructor(sc, pl, sp, inv) { this.sc = sc; this.pl = pl; this.sp = sp; this.inv = inv;
    this.st = 'ready'; this.hi = null; this.onC = null; this.fd = new THREE.Vector3();
    /* Reusable objects for _orientHook and update to avoid per-frame allocation */
    this._hookQuat = new THREE.Quaternion();
    this._hookDefaultDir = new THREE.Vector3(0, 1, 0);
    this._hookDir = new THREE.Vector3();
    this._pullDir = new THREE.Vector3();
    this._itemPos = new THREE.Vector3();
    // Hook 3D model: cone tip pointing +Y (outward), half torus at base
    var g = new THREE.Group();
    var hg = new THREE.ConeGeometry(0.1, 0.4, 6), hm = new THREE.MeshLambertMaterial({ color: 0x888888 });
    var h = new THREE.Mesh(hg, hm); h.position.y = 0.2; g.add(h);
    var tg = new THREE.TorusGeometry(0.12, 0.03, 6, 8, Math.PI);
    var t = new THREE.Mesh(tg, hm); t.position.y = -0.05; t.rotation.x = Math.PI / 2; g.add(t);
    this.hm = g; g.visible = false; sc.add(g);
    // Rope line
    var lg = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
    this.rope = new THREE.Line(lg, new THREE.LineBasicMaterial({ color: 0xC4A35A }));
    this.rope.visible = false; sc.add(this.rope); }
  cast(targetDir) { if (this.st !== 'ready') return; this.st = 'flying'; this.hi = null;
    this.hm.position.copy(this.pl.charPos()); this.hm.visible = true; this.rope.visible = true;
    if (targetDir) { this.fd.copy(targetDir); } else { this.fd.copy(this.pl.look()); }
    if (this.fd.y > 0.3) { this.fd.y = 0.3; this.fd.normalize(); }
    this._orientHook(); }
  _orientHook() {
    /* Orient hook so the cone tip points along the flight direction - reuse vectors */
    this._hookDir.copy(this.fd).normalize();
    this._hookQuat.setFromUnitVectors(this._hookDefaultDir, this._hookDir);
    this.hm.quaternion.copy(this._hookQuat);
  }
  update(dt) { if (this.st === 'ready') { this.hm.visible = false; this.rope.visible = false; return; }
    var hp = this.hm.position, pp = this.pl.charPos();
    var rp = this.rope.geometry.attributes.position;
    rp.setXYZ(0, pp.x, pp.y, pp.z); rp.setXYZ(1, hp.x, hp.y, hp.z); rp.needsUpdate = true;
    if (this.st === 'flying') {
      /* Move hook along flight direction - avoid clone() */
      var hs = CONFIG.HS * dt;
      hp.x += this.fd.x * hs; hp.y += this.fd.y * hs; hp.z += this.fd.z * hs;
      this.fd.y -= 3 * dt;
      this._orientHook();
      if (hp.y <= CONFIG.FY + 0.2) { hp.y = CONFIG.FY + 0.2;
        var its = this.sp.get(), best = null, bd = CONFIG.HGR * CONFIG.HGR;
        for (var i = 0; i < its.length; i++) {
          var ip = its[i].mesh.position;
          var dx = ip.x - hp.x, dy = ip.y - hp.y, dz = ip.z - hp.z;
          var d2 = dx*dx + dy*dy + dz*dz;
          if (d2 < bd) { bd = d2; best = its[i]; }
        }
        if (best) this.hi = best; this.st = 'pulling'; }
      var dx2 = hp.x-pp.x, dy2 = hp.y-pp.y, dz2 = hp.z-pp.z;
      if (dx2*dx2+dy2*dy2+dz2*dz2 > CONFIG.HR*CONFIG.HR) this.st = 'pulling'; }
    else if (this.st === 'pulling') {
      /* Pull hook back toward player - reuse _pullDir */
      this._pullDir.set(pp.x - hp.x, pp.y - hp.y, pp.z - hp.z).normalize();
      this.fd.copy(this._pullDir); this._orientHook();
      var ps = CONFIG.HPS * dt;
      hp.x += this._pullDir.x * ps; hp.y += this._pullDir.y * ps; hp.z += this._pullDir.z * ps;
      if (this.hi && this.hi.alive) this.hi.mesh.position.copy(hp);
      var cx = hp.x-pp.x, cy = hp.y-pp.y, cz = hp.z-pp.z;
      if (cx*cx+cy*cy+cz*cz < 4) { if (this.hi && this.hi.alive) { this.inv.add(this.hi.type);
        if (this.onC) this.onC(this.hi.type); this.hi.die(); this.hi = null; } this.st = 'ready'; } } }
}

/* ===== Paddle - push raft toward target position on sea ===== */
class Paddle {
  constructor(sc, pl, raft, cam) {
    this.sc = sc; this.pl = pl; this.raft = raft; this.cam = cam; this.cd = 0;
    this.target = null; this.hasTarget = false;
    this.markerTimer = 0; // Timer for marker auto-fade (1 second)
    /* Target marker: small white semi-transparent dot */
    var mg = new THREE.SphereGeometry(0.1, 12, 12);
    var mm = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
    this.marker = new THREE.Mesh(mg, mm); this.marker.visible = false; sc.add(this.marker);
    this.markerMat = mm;
    /* Raycaster for clicking on sea */
    this.ray = new THREE.Raycaster();
  }
  /* Set target by raycasting from mouse position onto the sea plane (y=0) */
  setTarget(ocean, ndc) {
    this.ray.setFromCamera(ndc || new THREE.Vector2(0, 0), this.cam);
    var dir = this.ray.ray.direction, org = this.ray.ray.origin;
    if (dir.y >= 0) return; // looking up, no intersection
    var t = -org.y / dir.y;
    if (t < 0 || t > 500) return;
    var hit = org.clone().add(dir.clone().multiplyScalar(t));
    this.target = new THREE.Vector3(hit.x, 0, hit.z);
    this.hasTarget = true;
    this.markerTimer = 1.0; // 1 second fade timer
    this.marker.position.set(hit.x, CONFIG.FY + 0.3, hit.z);
    this.marker.visible = true;
    this.markerMat.opacity = 0.3;
  }
  /* Continuously move raft toward the target */
  update(dt, et) {
    if (this.cd > 0) this.cd -= dt;
    /* Update marker fade - auto disappear after 1 second */
    if (this.markerTimer > 0) {
      this.markerTimer -= dt;
      if (this.markerTimer <= 0.4) {
        this.markerMat.opacity = Math.max(0, this.markerTimer / 0.4) * 0.3;
      }
      if (this.markerTimer <= 0) {
        this.marker.visible = false;
        this.markerTimer = 0;
      }
    }
    if (this.hasTarget && this.target) {
      var rp = this.raft.g.position;
      var dx = this.target.x - rp.x, dz = this.target.z - rp.z;
      var dist = Math.sqrt(dx * dx + dz * dz);
      if (dist < 1.5) {
        /* Arrived at target */
        this.hasTarget = false;
        this.raft.vel.set(0, 0, 0);
      } else {
        /* Set raft velocity directly toward target at paddle speed, slowing near target */
        var speed = Math.min(CONFIG.PADDLE_SPEED, dist * 0.5) / dist;
        this.raft.vel.set(dx * speed, 0, dz * speed);
      }
    }
  }
}

/* ===== WaterPurifier - placed on raft edge, generates 1 freshwater per minute ===== */
class WaterPurifier {
  constructor(sc, raft, inv) {
    this.sc = sc; this.raft = raft; this.inv = inv;
    this.purifiers = []; // { gx, gz, side, mesh, timer }
    this._waterTimer = 0;
  }
  /* Check if a plank at gx,gz has at least one side exposed to sea (no adjacent plank) */
  _isEdgePlank(gx, gz) {
    var dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for (var d = 0; d < dirs.length; d++) {
      var nx = gx + dirs[d][0], nz = gz + dirs[d][1];
      if (!this.raft.occ.has(nx + ',' + nz)) return true;
    }
    return false;
  }
  /* Get all edge plank positions where purifiers can be placed */
  getEdgeSlots() {
    var slots = [], occupied = new Set();
    this.purifiers.forEach(function(p) { occupied.add(p.gx + ',' + p.gz); });
    for (var i = 0; i < this.raft.planks.length; i++) {
      var p = this.raft.planks[i];
      var k = p.x + ',' + p.z;
      if (!occupied.has(k) && this._isEdgePlank(p.x, p.z)) {
        slots.push({ x: p.x, z: p.z });
      }
    }
    return slots;
  }
  /* Build a purifier mesh (barrel-like structure with filter on the side) */
  _createPurifierMesh(gx, gz) {
    var g = new THREE.Group();
    var s = CONFIG.RPS;
    /* Base container - barrel */
    var barrelGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.8, 12);
    var barrelMat = new THREE.MeshLambertMaterial({ color: 0x446688 });
    var barrel = new THREE.Mesh(barrelGeo, barrelMat);
    barrel.position.y = 0.55; barrel.castShadow = true; g.add(barrel);
    /* Barrel hoops */
    var hoopGeo = new THREE.TorusGeometry(0.36, 0.03, 6, 12);
    var hoopMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
    var hoop1 = new THREE.Mesh(hoopGeo, hoopMat);
    hoop1.rotation.x = Math.PI/2; hoop1.position.y = 0.7; g.add(hoop1);
    var hoop2 = new THREE.Mesh(hoopGeo.clone(), hoopMat.clone());
    hoop2.rotation.x = Math.PI/2; hoop2.position.y = 0.4; g.add(hoop2);
    /* Filter tube going down into water */
    var tubeGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8);
    var tubeMat = new THREE.MeshLambertMaterial({ color: 0x334455 });
    var tube = new THREE.Mesh(tubeGeo, tubeMat);
    tube.position.set(0, 0.1, 0.3); g.add(tube);
    /* Output spout */
    var spoutGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.3, 6);
    var spoutMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
    var spout = new THREE.Mesh(spoutGeo, spoutMat);
    spout.rotation.z = Math.PI/2; spout.position.set(0.4, 0.55, 0); g.add(spout);
    /* Water drop indicator (blue glowing dot) */
    var dropGeo = new THREE.SphereGeometry(0.06, 8, 8);
    var dropMat = new THREE.MeshBasicMaterial({ color: 0x44aaff });
    this._dropMesh = new THREE.Mesh(dropGeo, dropMat);
    this._dropMesh.position.set(0.55, 0.55, 0); g.add(this._dropMesh);
    /* Position group on plank */
    g.position.set(gx * s, CONFIG.RPH / 2, gz * s);
    this.raft.g.add(g);
    return g;
  }
  addPurifier(gx, gz) {
    var k = gx + ',' + gz;
    /* Can only place on edge planks */
    if (!this.raft.occ.has(k)) return false;
    if (!this._isEdgePlank(gx, gz)) return false;
    /* Only one per plank */
    for (var i = 0; i < this.purifiers.length; i++) {
      if (this.purifiers[i].gx === gx && this.purifiers[i].gz === gz) return false;
    }
    var mesh = this._createPurifierMesh(gx, gz);
    this.purifiers.push({ gx: gx, gz: gz, mesh: mesh, timer: 0 });
    return true;
  }
  removePurifier(gx, gz) {
    for (var i = 0; i < this.purifiers.length; i++) {
      if (this.purifiers[i].gx === gx && this.purifiers[i].gz === gz) {
        this.raft.g.remove(this.purifiers[i].mesh);
        this.purifiers[i].mesh.traverse(function(c) {
          if (c.geometry) c.geometry.dispose();
          if (c.material) c.material.dispose();
        });
        this.purifiers.splice(i, 1);
        return true;
      }
    }
    return false;
  }
  showEdgeSlots() {
    this._slotMeshes = [];
    var slots = this.getEdgeSlots(), s = CONFIG.RPS;
    for (var i = 0; i < slots.length; i++) {
      var geo = new THREE.BoxGeometry(s - 0.1, 0.08, s - 0.1);
      var mat = new THREE.MeshBasicMaterial({ color: 0x44ccff, transparent: true, opacity: 0.4 });
      var m = new THREE.Mesh(geo, mat);
      m.position.set(slots[i].x * s, CONFIG.RPH / 2 + 0.06, slots[i].z * s);
      m.userData = { gx: slots[i].x, gz: slots[i].z, purifierSlot: true };
      this.raft.g.add(m);
      this._slotMeshes.push(m);
    }
    return this._slotMeshes;
  }
  hideEdgeSlots() {
    if (!this._slotMeshes) return;
    for (var i = 0; i < this._slotMeshes.length; i++) {
      this.raft.g.remove(this._slotMeshes[i]);
      this._slotMeshes[i].geometry.dispose();
      this._slotMeshes[i].material.dispose();
    }
    this._slotMeshes = [];
  }
  getSlotMeshes() { return this._slotMeshes || []; }
  update(dt) {
    if (this.purifiers.length === 0) return;
    this._waterTimer += dt;
    /* Generate 1 water per minute per purifier */
    var waterPerMin = this.purifiers.length;
    if (this._waterTimer >= 60) {
      this._waterTimer -= 60;
      this.inv.add('freshwater', waterPerMin);
      return waterPerMin; // signal for UI notification
    }
    return 0;
  }
  /* Serialize for save */
  serialize() {
    return this.purifiers.map(function(p) { return { gx: p.gx, gz: p.gz }; });
  }
  /* Restore from save */
  restore(data) {
    if (!data) return;
    for (var i = 0; i < data.length; i++) {
      this.addPurifier(data[i].gx, data[i].gz);
    }
  }
}

/* ===== FishingSystem - cast rod, wait for bite, click to catch ===== */
class FishingSystem {
  constructor(sc, raft, inv, cam) {
    this.sc = sc; this.raft = raft; this.inv = inv; this.cam = cam;
    this.state = 'idle'; // idle | casting | waiting | biting
    this.castPoint = null; // where the hook landed (world pos)
    this.waitTimer = 0;  // time until fish bites
    this.biteTimer = 0;  // countdown after fish bites (5s)
    this.fishMesh = null; // clickable fish mesh
    this._ripples = [];   // { mesh, age, maxAge } - expanding ring meshes
    this._ray = new THREE.Raycaster();
    this._biteFishPos = null;
    /* Fishing hint element */
    this.hintEl = document.getElementById('fishing-hint');
    this.biteEl = document.getElementById('fishing-bite');
    /* Fish mesh template */
    this._buildFishMesh();
  }
  _buildFishMesh() {
    /* A simple fish shape: body + tail */
    var g = new THREE.Group();
    var bodyGeo = new THREE.SphereGeometry(0.22, 8, 6);
    var bodyMat = new THREE.MeshLambertMaterial({ color: 0xff9944 });
    var body = new THREE.Mesh(bodyGeo, bodyMat);
    body.scale.set(1.8, 0.6, 0.8); body.castShadow = true; g.add(body);
    /* Tail */
    var tailGeo = new THREE.ConeGeometry(0.18, 0.25, 4);
    var tailMat = new THREE.MeshLambertMaterial({ color: 0xff7722 });
    var tail = new THREE.Mesh(tailGeo, tailMat);
    tail.rotation.z = Math.PI/2; tail.position.x = -0.42; g.add(tail);
    /* Eye */
    var eyeGeo = new THREE.SphereGeometry(0.05, 6, 6);
    var eyeMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
    var eye = new THREE.Mesh(eyeGeo, eyeMat);
    eye.position.set(0.3, 0.1, 0.14); g.add(eye);
    g.visible = false;
    this.sc.add(g);
    this.fishMesh = g;
  }
  /* Cast rod at a world position on sea surface (y ~ 0) */
  castAt(worldPos) {
    if (this.state !== 'idle') return;
    this.castPoint = worldPos.clone();
    this.castPoint.y = CONFIG.FY + 0.05;
    this.state = 'waiting';
    /* Random wait: 2-6 seconds before bite */
    this.waitTimer = 2 + Math.random() * 4;
    /* Create initial ripple */
    this._spawnRipple(this.castPoint.clone());
    this.hintEl.textContent = 'ç­‰å¾…é±¼å’¬é’©...';
  }
  _spawnRipple(pos) {
    var geo = new THREE.RingGeometry(0.1, 0.18, 24);
    var mat = new THREE.MeshBasicMaterial({ color: 0xaaddff, transparent: true, opacity: 0.7, side: THREE.DoubleSide });
    var m = new THREE.Mesh(geo, mat);
    m.rotation.x = -Math.PI/2;
    m.position.copy(pos);
    m.position.y = CONFIG.FY + 0.06;
    this.sc.add(m);
    this._ripples.push({ mesh: m, age: 0, maxAge: 2.0, startScale: 1 });
  }
  _updateRipples(dt) {
    var alive = 0;
    for (var i = 0; i < this._ripples.length; i++) {
      var r = this._ripples[i];
      r.age += dt;
      var t = r.age / r.maxAge;
      if (t >= 1) { this.sc.remove(r.mesh); r.mesh.geometry.dispose(); r.mesh.material.dispose(); continue; }
      var scale = 1 + t * 6;
      r.mesh.scale.set(scale, scale, scale);
      r.mesh.material.opacity = (1 - t) * 0.7;
      this._ripples[alive++] = r;
    }
    this._ripples.length = alive;
  }
  showBite() {
    if (!this.castPoint) return;
    /* Show fish mesh near cast point */
    this.fishMesh.position.copy(this.castPoint);
    this.fishMesh.position.y = CONFIG.FY + 0.15;
    this.fishMesh.visible = true;
    this.fishMesh.rotation.y = Math.random() * Math.PI * 2;
    this.biteTimer = 5.0;
    this.state = 'biting';
    /* Spawn a big ripple */
    this._spawnRipple(this.castPoint.clone());
    this._spawnRipple(this.castPoint.clone());
    /* Show bite UI */
    this.biteEl.innerHTML = 'ğŸŸ é±¼ä¸Šé’©äº†ï¼å¿«ç‚¹å‡»é‚£æ¡é±¼ï¼<br><span style="font-size:18px">å‰©ä½™ 5s</span>';
    this.biteEl.style.display = 'block';
    this.hintEl.textContent = 'é±¼å’¬é’©äº†ï¼å¿«ç‚¹å‡»é‚£æ¡é±¼ï¼';
  }
  tryClick(mouseX, mouseY, w, h) {
    if (this.state !== 'biting') return false;
    /* Raycast to fish mesh */
    var ndc = new THREE.Vector2((mouseX / w) * 2 - 1, -(mouseY / h) * 2 + 1);
    this._ray.setFromCamera(ndc, this.cam);
    var hits = this._ray.intersectObject(this.fishMesh, true);
    if (hits.length > 0) {
      this._catchFish();
      return true;
    }
    return false;
  }
  _catchFish() {
    this.inv.add('fish', 1);
    this._reset();
    return true;
  }
  _reset() {
    this.state = 'idle';
    this.castPoint = null;
    this.waitTimer = 0;
    this.biteTimer = 0;
    this.fishMesh.visible = false;
    this.biteEl.style.display = 'none';
    this.hintEl.textContent = '';
    /* Clear ripples */
    for (var i = 0; i < this._ripples.length; i++) {
      this.sc.remove(this._ripples[i].mesh);
      this._ripples[i].mesh.geometry.dispose();
      this._ripples[i].mesh.material.dispose();
    }
    this._ripples = [];
  }
  update(dt) {
    this._updateRipples(dt);
    if (this.state === 'waiting') {
      this.waitTimer -= dt;
      /* Spawn periodic small ripples near cast point */
      if (this.castPoint && Math.random() < dt * 0.8) {
        this._spawnRipple(this.castPoint.clone());
      }
      if (this.waitTimer <= 0) {
        this.showBite();
      }
    } else if (this.state === 'biting') {
      /* Animate fish bobbing */
      if (this.fishMesh.visible && this.castPoint) {
        this.fishMesh.position.y = CONFIG.FY + 0.15 + Math.sin(Date.now() * 0.008) * 0.06;
        this.fishMesh.rotation.y += dt * 1.5;
      }
      this.biteTimer -= dt;
      /* Update countdown in bite element */
      var secs = Math.ceil(this.biteTimer);
      this.biteEl.innerHTML = 'ğŸŸ é±¼ä¸Šé’©äº†ï¼å¿«ç‚¹å‡»é‚£æ¡é±¼ï¼<br><span style="font-size:18px">å‰©ä½™ ' + secs + 's</span>';
      if (this.biteTimer <= 0) {
        /* Timeout - fish escapes */
        this._reset();
        return 'timeout';
      }
    }
    return null;
  }
  /* Cancel fishing (e.g. when unequipping rod) */
  cancel() {
    if (this.state !== 'idle') this._reset();
  }
}

/* ===== BuildSystem - craft with resources (multi-layer support) ===== */
class BuildSystem {
  constructor(raft, inv, scene, player, purifier) {
    this.raft = raft; this.inv = inv; this.scene = scene; this.player = player; this.purifier = purifier;
    this.open = false; this.dirty = true;
    this.placing = false; this.placeType = null;
    this.placeLayer = 0; // Current layer for placement
    /* Real-time preview mesh for pillar/storage placement */
    this.previewMesh = null;
    this.previewType = null;
  }
  toggle() { this.open = !this.open; if (!this.open) this.cancelPlace(); }
  /* Get all layers that have available slots for the given type.
   * Every item type should be buildable on every layer that has a floor (ground planks or upper planks). */
  _getAvailableLayers(type) {
    var layers = [];
    var maxLayer = this._getMaxLayer();
    if (type === 'plank') {
      /* Layer 0: expand ground raft. Layer 1+: place upper planks. */
      if (this.raft.getExpandSlots().length > 0) layers.push(0);
      for (var l = 1; l <= maxLayer; l++) {
        var slots = this.raft.getUpperPlankSlots(l);
        if (slots.length > 0) layers.push(l);
      }
    } else if (type === 'pillar') {
      for (var l = 0; l <= maxLayer; l++) {
        var slots = this.raft.getPillarSlots(l);
        if (slots.length > 0) layers.push(l);
      }
    } else if (type === 'stairs') {
      for (var l = 0; l <= maxLayer; l++) {
        var slots = this.raft.getStairsSlots(l);
        if (slots.length > 0) layers.push(l);
      }
    } else if (type === 'upper_plank') {
      for (var l = 1; l <= maxLayer; l++) {
        var slots = this.raft.getUpperPlankSlots(l);
        if (slots.length > 0) layers.push(l);
      }
    } else if (type === 'storage') {
      for (var l = 0; l <= maxLayer; l++) {
        var slots = this.raft.getStorageSlots(l);
        if (slots.length > 0) layers.push(l);
      }
    } else if (type === 'purifier') {
      if (this.purifier.getEdgeSlots().length > 0) layers.push(0);
    }
    return layers;
  }
  /* Determine max layer that has pillars or upper planks */
  _getMaxLayer() {
    var max = 0;
    for (var i = 0; i < this.raft.pillars.length; i++) {
      max = Math.max(max, this.raft.pillars[i].layer + 1);
    }
    for (var i = 0; i < this.raft.upperPlanks.length; i++) {
      max = Math.max(max, this.raft.upperPlanks[i].layer + 1);
    }
    return max;
  }
  /* Create or update the preview mesh for current placement */
  _updatePreviewMesh(pos, size, y, color, opacity) {
    if (!this.previewMesh) {
      var geo = new THREE.BoxGeometry(1, 1, 1);
      var mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: opacity });
      this.previewMesh = new THREE.Mesh(geo, mat);
      this.scene.add(this.previewMesh);
    }
    this.previewMesh.scale.set(size.x, size.y, size.z);
    this.previewMesh.position.set(pos.x, y + size.y / 2, pos.z);
    this.previewMesh.material.color.setHex(color);
    this.previewMesh.material.opacity = opacity;
    this.previewMesh.visible = true;
  }
  /* Hide and clean up preview mesh */
  _hidePreviewMesh() {
    if (this.previewMesh) {
      this.previewMesh.visible = false;
    }
  }
  /* Pick the best default layer: prefer player's current layer if available, else nearest available */
  _pickDefaultLayer(layers, fallback) {
    if (layers.length === 0) return fallback;
    var playerLayer = this.player ? this.player.getCurrentLayer() : 0;
    if (layers.indexOf(playerLayer) >= 0) return playerLayer;
    /* Find the closest available layer to the player's current layer */
    var best = layers[0], bestDist = Math.abs(layers[0] - playerLayer);
    for (var i = 1; i < layers.length; i++) {
      var d = Math.abs(layers[i] - playerLayer);
      if (d < bestDist) { bestDist = d; best = layers[i]; }
    }
    return best;
  }
  /* Enter placement mode: show available slots, let player click to place */
  startPlace(type) {
    var cost = CONFIG.BR[type].cost;
    if (!this.inv.can(cost)) return { ok: false, msg: 'èµ„æºä¸è¶³ï¼' };
    /* fishing_rod is craft-only: directly add to inventory */
    if (CONFIG.BR[type].craftOnly) {
      this.inv.pay(cost);
      this.inv.fishingRodCount += 1;
      this.open = false;
      return { ok: true, msg: 'é±¼ç«¿å·²åˆ¶ä½œï¼æ‰“å¼€èƒŒåŒ…è£…å¤‡é±¼ç«¿ã€‚', noPlace: true };
    }
    this.placing = true;
    this.placeType = type;
    this.open = false;
    var hint = document.getElementById('place-hint');
    if (type === 'purifier') {
      this.purifier.showEdgeSlots();
      hint.textContent = 'ç‚¹å‡»æœ¨ç­è¾¹ç¼˜ï¼ˆé è¿‘æµ·é¢ï¼‰æ”¾ç½®æ·¡æ°´å‡€åŒ–å™¨ï¼ˆESC å–æ¶ˆï¼‰';
      hint.style.display = 'block';
      document.body.classList.add('placing-mode');
      return { ok: true, msg: '' };
    }
    if (type === 'plank') {
      var layers = this._getAvailableLayers('plank');
      this.placeLayer = this._pickDefaultLayer(layers, 0);
      if (this.placeLayer === 0) {
        this.raft.showSlots();
        hint.textContent = 'ç‚¹å‡»æœ¨ç­å‘¨å›´çš„é«˜äº®åŒºåŸŸæ‰©å»ºæœ¨ç­ [å±‚0] (æ»šè½®åˆ‡æ¢å±‚ï¼ŒESC å–æ¶ˆ)';
      } else {
        this.raft.showUpperPlankSlots(this.placeLayer);
        hint.textContent = 'ç‚¹å‡»é«˜äº®åŒºåŸŸé“ºè®¾æœ¨æ¿ [å±‚' + this.placeLayer + '] (æ»šè½®åˆ‡æ¢å±‚ï¼ŒESC å–æ¶ˆ)';
      }
    } else if (type === 'pillar') {
      var layers = this._getAvailableLayers('pillar');
      this.placeLayer = this._pickDefaultLayer(layers, 0);
      this.raft.showPillarSlots(this.placeLayer);
      hint.textContent = 'ç‚¹å‡»é«˜äº®åŒºåŸŸå»ºé€ æŸ±å­ [å±‚' + this.placeLayer + '] (æ»šè½®åˆ‡æ¢å±‚ï¼ŒESC å–æ¶ˆ)';
    } else if (type === 'stairs') {
      var layers = this._getAvailableLayers('stairs');
      this.placeLayer = this._pickDefaultLayer(layers, 0);
      this.raft.showStairsSlots(this.placeLayer);
      hint.textContent = 'ç‚¹å‡»é«˜äº®åŒºåŸŸæ”¾ç½®æ¥¼æ¢¯ [å±‚' + this.placeLayer + '] (æ»šè½®åˆ‡æ¢å±‚ï¼ŒESC å–æ¶ˆ)';
    } else if (type === 'upper_plank') {
      /* Upper planks go on layer 1+ (above pillars) */
      var layers = this._getAvailableLayers('upper_plank');
      var playerLayer = this.player ? this.player.getCurrentLayer() : 0;
      /* For upper planks, default to playerLayer+1 if player is on ground, else playerLayer */
      var preferLayer = playerLayer === 0 ? 1 : playerLayer;
      if (layers.indexOf(preferLayer) >= 0) this.placeLayer = preferLayer;
      else this.placeLayer = this._pickDefaultLayer(layers, 1);
      this.raft.showUpperPlankSlots(this.placeLayer);
      hint.textContent = 'ç‚¹å‡»é«˜äº®åŒºåŸŸé“ºè®¾ä¸Šå±‚æœ¨æ¿ [å±‚' + this.placeLayer + '] (æ»šè½®åˆ‡æ¢å±‚ï¼ŒESC å–æ¶ˆ)';
    } else if (type === 'storage') {
      var layers = this._getAvailableLayers('storage');
      this.placeLayer = this._pickDefaultLayer(layers, 0);
      this.raft.showStorageSlots(this.placeLayer);
      hint.textContent = 'ç‚¹å‡»é«˜äº®åŒºåŸŸå»ºé€ å‚¨ç‰©ç®± [å±‚' + this.placeLayer + '] (æ»šè½®åˆ‡æ¢å±‚ï¼ŒESC å–æ¶ˆ)';
    } else {
      this.raft.showPlankSlots();
      hint.textContent = 'ç‚¹å‡»æœ¨ç­ä¸Šçš„é«˜äº®åŒºåŸŸæ”¾ç½®ç‰©å“ï¼ˆESC å–æ¶ˆï¼‰';
    }
    hint.style.display = 'block';
    document.body.classList.add('placing-mode');
    return { ok: true, msg: '' };
  }
  /* Confirm placement at grid position (with optional sub-grid coordinates) */
  confirmPlace(gx, gz, layer, sx, sz) {
    if (!this.placing) return;
    var type = this.placeType;
    var cost = CONFIG.BR[type].cost;
    this.inv.pay(cost);
    if (type === 'purifier') {
      var result = this.purifier.addPurifier(gx, gz);
      this.cancelPlace();
      return result ? { ok: true, msg: 'æ·¡æ°´å‡€åŒ–å™¨å·²å®‰è£…ï¼æ¯åˆ†é’Ÿäº§ç”Ÿ1å•ä½æ·¡æ°´ã€‚' } : { ok: false, msg: 'æ— æ³•åœ¨æ­¤å¤„å®‰è£…å‡€åŒ–å™¨' };
    }
    if (type === 'plank') {
      var l = layer !== undefined ? layer : this.placeLayer;
      if (l === 0) {
        this.raft.addPlank(gx, gz);
        this.cancelPlace();
        return { ok: true, msg: 'æœ¨ç­å·²æ‰©å»ºï¼' };
      } else {
        var result = this.raft.addUpperPlank(gx, gz, l);
        this.cancelPlace();
        return result ? { ok: true, msg: 'æœ¨æ¿å·²é“ºè®¾ï¼' } : { ok: false, msg: 'æ— æ³•åœ¨æ­¤å¤„é“ºè®¾æœ¨æ¿' };
      }
    } else if (type === 'pillar') {
      var l = layer !== undefined ? layer : this.placeLayer;
      var result = this.raft.addPillar(gx, gz, l, sx, sz);
      this.cancelPlace();
      return result ? { ok: true, msg: 'æŸ±å­å·²å»ºé€ ï¼' } : { ok: false, msg: 'æ— æ³•åœ¨æ­¤å¤„å»ºé€ æŸ±å­' };
    } else if (type === 'stairs') {
      var l = layer !== undefined ? layer : this.placeLayer;
      this.raft.addStairs(gx, gz, l);
      this.cancelPlace();
      return { ok: true, msg: 'æ¥¼æ¢¯å·²å»ºé€ ï¼' };
    } else if (type === 'upper_plank') {
      var l = layer !== undefined ? layer : this.placeLayer;
      this.raft.addUpperPlank(gx, gz, l);
      this.cancelPlace();
      return { ok: true, msg: 'ä¸Šå±‚æœ¨æ¿å·²é“ºè®¾ï¼' };
    } else if (type === 'storage') {
      var l = layer !== undefined ? layer : this.placeLayer;
      var result = this.raft.addStorage(gx, gz, l, sx, sz);
      this.cancelPlace();
      return result ? { ok: true, msg: 'å‚¨ç‰©ç®±å·²å»ºé€ ï¼' } : { ok: false, msg: 'æ— æ³•åœ¨æ­¤å¤„æ”¾ç½®å‚¨ç‰©ç®±' };
    }
    this.cancelPlace();
    return { ok: false, msg: 'å»ºé€ å¤±è´¥' };
  }
  /* Cancel placement mode */
  cancelPlace() {
    this.placing = false;
    this.placeType = null;
    this.raft.hideSlots();
    if (this.purifier) this.purifier.hideEdgeSlots();
    this._hidePreviewMesh();
    document.getElementById('place-hint').style.display = 'none';
    document.body.classList.remove('placing-mode');
  }
  /* Change current placement layer */
  changeLayer(delta) {
    var type = this.placeType;
    var layers = this._getAvailableLayers(type);
    if (layers.length === 0) return;
    var idx = layers.indexOf(this.placeLayer);
    if (idx < 0) idx = 0;
    idx = (idx + delta + layers.length) % layers.length;
    this.placeLayer = layers[idx];
    /* Update hint text and slot display */
    var hint = document.getElementById('place-hint');
    this.raft.hideSlots();
    if (type === 'plank') {
      if (this.placeLayer === 0) {
        this.raft.showSlots();
        hint.textContent = 'ç‚¹å‡»æœ¨ç­å‘¨å›´çš„é«˜äº®åŒºåŸŸæ‰©å»ºæœ¨ç­ [å±‚0] (æ»šè½®åˆ‡æ¢å±‚ï¼ŒESC å–æ¶ˆ)';
      } else {
        this.raft.showUpperPlankSlots(this.placeLayer);
        hint.textContent = 'ç‚¹å‡»é«˜äº®åŒºåŸŸé“ºè®¾æœ¨æ¿ [å±‚' + this.placeLayer + '] (æ»šè½®åˆ‡æ¢å±‚ï¼ŒESC å–æ¶ˆ)';
      }
    } else if (type === 'pillar') {
      this.raft.showPillarSlots(this.placeLayer);
      hint.textContent = 'ç‚¹å‡»é«˜äº®åŒºåŸŸå»ºé€ æŸ±å­ [å±‚' + this.placeLayer + '] (æ»šè½®åˆ‡æ¢å±‚ï¼ŒESC å–æ¶ˆ)';
    } else if (type === 'storage') {
      this.raft.showStorageSlots(this.placeLayer);
      hint.textContent = 'ç‚¹å‡»é«˜äº®åŒºåŸŸå»ºé€ å‚¨ç‰©ç®± [å±‚' + this.placeLayer + '] (æ»šè½®åˆ‡æ¢å±‚ï¼ŒESC å–æ¶ˆ)';
    } else if (type === 'upper_plank') {
      this.raft.showUpperPlankSlots(this.placeLayer);
      hint.textContent = 'ç‚¹å‡»é«˜äº®åŒºåŸŸé“ºè®¾ä¸Šå±‚æœ¨æ¿ [å±‚' + this.placeLayer + '] (æ»šè½®åˆ‡æ¢å±‚ï¼ŒESC å–æ¶ˆ)';
    } else if (type === 'stairs') {
      this.raft.showStairsSlots(this.placeLayer);
      hint.textContent = 'ç‚¹å‡»é«˜äº®åŒºåŸŸæ”¾ç½®æ¥¼æ¢¯ [å±‚' + this.placeLayer + '] (æ»šè½®åˆ‡æ¢å±‚ï¼ŒESC å–æ¶ˆ)';
    }
  }
  build(k) { var r = CONFIG.BR[k]; if (!r) return { ok: false, msg: 'æœªçŸ¥' };
    if (!this.inv.can(r.cost)) return { ok: false, msg: 'èµ„æºä¸è¶³ï¼' };
    var result = this.startPlace(k);
    return result; }
}

/* ===== DemolishSystem - demolish placed structures and refund half resources ===== */
class DemolishSystem {
  constructor(raft, inv) {
    this.raft = raft; this.inv = inv;
    this.open = false;        // Menu open
    this.placing = false;     // In demolish-click mode
    this.placeType = null;    // Which type we're demolishing
  }
  toggle() {
    this.open = !this.open;
    if (!this.open) this.cancelPlace();
  }
  /* Get a list of demolishable item types and their counts */
  getDemolishableItems() {
    var items = [];
    /* Ground planks (excluding the last one) */
    var removablePlanks = 0;
    for (var i = 0; i < this.raft.planks.length; i++) {
      if (this.raft.planks.length <= 1) break;
      var p = this.raft.planks[i];
      if (this.raft._hasPillarOnPlank(p.x, p.z, 0)) continue;
      if (this.raft.stairOcc.has(p.x + ',' + p.z + ',0')) continue;
      var stKey = p.x + ',' + p.z + ',0';
      if (this.raft.storageOcc.has(stKey) && this.raft.storageOcc.get(stKey).size > 0) continue;
      removablePlanks++;
    }
    if (removablePlanks > 0) {
      items.push({ type: 'plank', name: 'æœ¨ç­æœ¨æ¿', icon: 'ç­', count: removablePlanks, cost: CONFIG.BR.plank.cost });
    }
    /* Pillars */
    if (this.raft.pillars.length > 0) {
      items.push({ type: 'pillar', name: 'æŸ±å­', icon: 'æŸ±', count: this.raft.pillars.length, cost: CONFIG.BR.pillar.cost });
    }
    /* Stairs */
    if (this.raft.stairs.length > 0) {
      items.push({ type: 'stairs', name: 'æ¥¼æ¢¯', icon: 'æ¢¯', count: this.raft.stairs.length, cost: CONFIG.BR.stairs.cost });
    }
    /* Upper planks */
    var removableUpper = 0;
    for (var i = 0; i < this.raft.upperPlanks.length; i++) {
      var u = this.raft.upperPlanks[i];
      if (this.raft._hasPillarOnPlank(u.x, u.z, u.layer)) continue;
      if (this.raft.stairOcc.has(u.x + ',' + u.z + ',' + u.layer)) continue;
      var stKey = u.x + ',' + u.z + ',' + u.layer;
      if (this.raft.storageOcc.has(stKey) && this.raft.storageOcc.get(stKey).size > 0) continue;
      removableUpper++;
    }
    if (removableUpper > 0) {
      items.push({ type: 'upper_plank', name: 'ä¸Šå±‚æœ¨æ¿', icon: 'æ¿', count: removableUpper, cost: CONFIG.BR.upper_plank.cost });
    }
    /* Storage boxes */
    if (this.raft.storages.length > 0) {
      items.push({ type: 'storage', name: 'å‚¨ç‰©ç®±', icon: 'ç®±', count: this.raft.storages.length, cost: CONFIG.BR.storage.cost });
    }
    return items;
  }
  /* Calculate half cost refund (rounded down) */
  getRefund(cost) {
    var refund = {};
    var entries = Object.entries(cost);
    for (var i = 0; i < entries.length; i++) {
      refund[entries[i][0]] = Math.floor(entries[i][1] / 2);
    }
    return refund;
  }
  /* Get refund display string */
  getRefundStr(cost) {
    var CN = { wood: 'æœ¨æ', rope: 'ç»³å­', plastic: 'å¡‘æ–™', iron: 'é“æ¿', copper: 'é“œæ¿', gold: 'é‡‘å—' };
    var refund = this.getRefund(cost);
    var parts = [];
    var entries = Object.entries(refund);
    for (var i = 0; i < entries.length; i++) {
      if (entries[i][1] > 0) parts.push((CN[entries[i][0]] || entries[i][0]) + ':' + entries[i][1]);
    }
    return parts.length > 0 ? 'è¿”è¿˜ ' + parts.join(' ') : 'æ— è¿”è¿˜';
  }
  /* Start demolish mode for a type */
  startPlace(type) {
    this.placing = true;
    this.placeType = type;
    this.open = false;
    this.raft.showDemolishTargets(type);
    var hint = document.getElementById('place-hint');
    var typeNames = { plank: 'æœ¨ç­æœ¨æ¿', pillar: 'æŸ±å­', stairs: 'æ¥¼æ¢¯', upper_plank: 'ä¸Šå±‚æœ¨æ¿', storage: 'å‚¨ç‰©ç®±' };
    hint.textContent = 'ç‚¹å‡»çº¢è‰²é«˜äº®åŒºåŸŸæ‹†é™¤' + (typeNames[type] || type) + 'ï¼ˆESC å–æ¶ˆï¼‰';
    hint.style.display = 'block';
    document.body.classList.add('demolish-mode');
  }
  /* Confirm demolish at a specific target (from raycasted userData) */
  confirmDemolish(ud) {
    if (!this.placing) return null;
    var type = ud.demolishType;
    var cost = CONFIG.BR[type] ? CONFIG.BR[type].cost : {};
    var refund = this.getRefund(cost);
    var ok = false;
    if (type === 'plank') {
      ok = this.raft.removePlank(ud.gx, ud.gz);
    } else if (type === 'pillar') {
      ok = this.raft.removePillar(ud.gx, ud.gz, ud.layer, ud.sx, ud.sz);
    } else if (type === 'stairs') {
      ok = this.raft.removeStairs(ud.gx, ud.gz, ud.layer);
    } else if (type === 'upper_plank') {
      ok = this.raft.removeUpperPlank(ud.gx, ud.gz, ud.layer);
    } else if (type === 'storage') {
      ok = this.raft.removeStorage(ud.gx, ud.gz, ud.layer, ud.sx, ud.sz);
    }
    if (ok) {
      /* Refund half resources */
      var entries = Object.entries(refund);
      for (var i = 0; i < entries.length; i++) {
        if (entries[i][1] > 0) this.inv.add(entries[i][0], entries[i][1]);
      }
      this.cancelPlace();
      return { ok: true, msg: 'å·²æ‹†é™¤ï¼èµ„æºå·²è¿”è¿˜åˆ°èƒŒåŒ…' };
    }
    return { ok: false, msg: 'æ— æ³•æ‹†é™¤æ­¤ç‰©å“' };
  }
  /* Cancel demolish mode */
  cancelPlace() {
    this.placing = false;
    this.placeType = null;
    this.raft.hideSlots();
    document.getElementById('place-hint').style.display = 'none';
    document.body.classList.remove('demolish-mode');
  }
}

/* ===== UIManager - HUD rendering ===== */
class UIManager {
  constructor(inv, bs, inp, ds) { this.inv = inv; this.bs = bs; this.inp = inp; this.ds = ds; this.act = 0;
    this.bpOpen = false; // Backpack open state
    this.dmOpen = false; // Demolish menu open state
    this.observeMode = false; // Observe mode state
    this._buildMenuDirty = true; this._backpackDirty = true; this._demolishDirty = true;
    this.tb = document.getElementById('toolbar'); this.tt = document.getElementById('tooltip');
    this.cl = document.getElementById('collect-log'); this.bm = document.getElementById('build-menu');
    this.bl = document.getElementById('build-list');
    this.bpm = document.getElementById('backpack-menu'); this.bpl = document.getElementById('backpack-list');
    this.dmm = document.getElementById('demolish-menu'); this.dml = document.getElementById('demolish-list');
    this.ttT = 0;
    this.onEquipChange = null; // callback(tool) when equip changes
    this._init(); }
  _init() {
    /* Only tool slots + backpack + demolish + observe button in toolbar */
    var tools = [{ i: 'ğŸª', l: 'é’©å­', k: '1' }, { i: 'ğŸ›¶', l: 'èˆ¹æ¡¨', k: '2' }, { i: 'ğŸ”¨', l: 'å»ºé€ ', k: '3' }, { i: 'ğŸ’', l: 'èƒŒåŒ…', k: '4' }, { i: 'ğŸ—‘ï¸', l: 'æ‹†é™¤', k: '6' }, { i: 'ğŸ‘ï¸', l: 'è§‚å¯Ÿ', k: '7' }];
    this.tb.innerHTML = ''; var s = this;
    for (var i = 0; i < tools.length; i++) { var t = tools[i], d = document.createElement('div');
      d.className = 'toolbar-slot' + (i === 0 ? ' active' : '');
      d.innerHTML = '<span class="key-hint">' + t.k + '</span><span class="icon">' + t.i + '</span><span class="label">' + t.l + '</span>';
      if (i === 0) {
        this._tool1Slot = d;
        d.addEventListener('click', function() { s.setA(0); });
      } else if (i === 1) {
        (function(x) { d.addEventListener('click', function() { s.setA(x); }); })(i);
      } else if (i === 2) {
        d.addEventListener('click', function() { s.toggleBuild(); });
      } else if (i === 3) {
        d.addEventListener('click', function() { s.toggleBackpack(); });
      } else if (i === 4) {
        d.addEventListener('click', function() { s.toggleDemolish(); });
      } else if (i === 5) {
        d.addEventListener('click', function() { s.toggleObserveMode(); });
      }
      this.tb.appendChild(d);
    }
  }
  /* Update toolbar slot 1 to reflect current equipped tool */
  _updateTool1Slot() {
    if (!this._tool1Slot) return;
    if (this.inv.equippedTool === 'fishing_rod') {
      this._tool1Slot.querySelector('.icon').textContent = 'ğŸ£';
      this._tool1Slot.querySelector('.label').textContent = 'é’“é±¼';
    } else {
      this._tool1Slot.querySelector('.icon').textContent = 'ğŸª';
      this._tool1Slot.querySelector('.label').textContent = 'é’©å­';
    }
  }
  setA(i) { this.act = i; var sl = this.tb.querySelectorAll('.toolbar-slot');
    for (var j = 0; j < sl.length; j++) if (j < 3) { if (j === i) sl[j].classList.add('active'); else sl[j].classList.remove('active'); }
    this.bpOpen = false; this.bs.open = false; this.dmOpen = false; this.ds.open = false;
    /* Show fishing hint only if on tool 1 with fishing rod equipped */
    var fishHint = document.getElementById('fishing-hint');
    if (fishHint) fishHint.style.display = (i === 0 && this.inv && this.inv.equippedTool === 'fishing_rod') ? 'block' : 'none';
    this._updateUIState();
  }
  toggleBackpack() {
    this.bpOpen = !this.bpOpen;
    if (this.bpOpen) { this.bs.open = false; this.dmOpen = false; this.ds.open = false; this.ds.cancelPlace(); this._backpackDirty = true; }
    this._updateUIState();
  }
  toggleBuild() {
    this.bs.toggle();
    if (this.bs.open) { this.bpOpen = false; this.dmOpen = false; this.ds.open = false; this.ds.cancelPlace(); this.act = 2; this._buildMenuDirty = true;
      var sl = this.tb.querySelectorAll('.toolbar-slot');
      for (var j = 0; j < sl.length; j++) if (j < 3) { if (j === 2) sl[j].classList.add('active'); else sl[j].classList.remove('active'); }
    }
    this._updateUIState();
  }
  toggleDemolish() {
    this.dmOpen = !this.dmOpen;
    this.ds.open = this.dmOpen;
    if (this.dmOpen) { this.bpOpen = false; this.bs.open = false; this.bs.cancelPlace(); this._demolishDirty = true; }
    else { this.ds.cancelPlace(); }
    this._updateUIState();
  }
  toggleObserveMode() {
    this.observeMode = !this.observeMode;
    /* Update toolbar button visual */
    var sl = this.tb.querySelectorAll('.toolbar-slot');
    if (sl.length > 5) {
      if (this.observeMode) sl[5].classList.add('active');
      else sl[5].classList.remove('active');
    }
    this.tip(this.observeMode ? 'è§‚å¯Ÿæ¨¡å¼å·²å¼€å¯ - é«˜å±‚å»ºç­‘å˜ä¸ºåŠé€æ˜' : 'è§‚å¯Ÿæ¨¡å¼å·²å…³é—­', 2);
  }
  closeAll() {
    this.bpOpen = false; this.bs.open = false; this.dmOpen = false; this.ds.open = false;
    this.bs.cancelPlace(); this.ds.cancelPlace();
    this._updateUIState();
  }
  isUIOpen() { return this.bpOpen || this.bs.open || this.dmOpen; }
  isAnyOverlay() { return this.bpOpen || this.bs.open || this.bs.placing || this.dmOpen || this.ds.placing; }
  _updateUIState() {
    var open = this.isAnyOverlay();
    this.inp.uiOpen = open;
  }
  tip(t, d) { this.tt.textContent = t; this.tt.classList.add('show'); this.ttT = d || 2; }
  col(type) { var info = IT[type], d = document.createElement('div'); d.className = 'collect-msg';
    d.textContent = '+ [' + info.icon + '] ' + info.name; this.cl.appendChild(d);
    this._buildMenuDirty = true; this._backpackDirty = true;
    setTimeout(function() { d.remove(); }, 2000); }
  update(dt) {
    if (this.ttT > 0) { this.ttT -= dt; if (this.ttT <= 0) this.tt.classList.remove('show'); }
    /* Build menu - only rebuild DOM when dirty to preserve click event targets */
    this.bm.style.display = this.bs.open ? 'block' : 'none';
    if (this.bs.open && this._buildMenuDirty) {
      this._buildMenuDirty = false;
      var CN = { wood: 'æœ¨æ', rope: 'ç»³å­', plastic: 'å¡‘æ–™', iron: 'é“æ¿', copper: 'é“œæ¿', gold: 'é‡‘å—' };
      this.bl.innerHTML = ''; var rk = Object.keys(CONFIG.BR), s = this;
      for (var k = 0; k < rk.length; k++) { var key = rk[k], rec = CONFIG.BR[key], can = this.inv.can(rec.cost);
        var ce = Object.entries(rec.cost), cs = '';
        for (var c = 0; c < ce.length; c++) { cs += (CN[ce[c][0]] || ce[c][0]) + ':' + ce[c][1]; if (c < ce.length - 1) cs += ' '; }
        var dv = document.createElement('div'); dv.className = 'build-item' + (can ? '' : ' disabled');
        var extraLabel = rec.craftOnly ? ' [åˆ¶ä½œ]' : '';
        dv.innerHTML = '<span>[' + rec.icon + '] ' + rec.name + extraLabel + '</span><span style="font-size:12px;color:#aaa">' + cs + '</span>';
        if (can) { (function(bk) { dv.addEventListener('click', function() {
          var r = s.bs.build(bk);
          if (r && r.msg) s.tip(r.msg, 3);
          s._buildMenuDirty = true; s._backpackDirty = true; s._updateUIState();
          if (r && r.noPlace) { /* craft-only: stay in build menu */ }
        }); })(key); }
        this.bl.appendChild(dv); }
    }
    /* Backpack menu - only rebuild DOM when dirty */
    this.bpm.style.display = this.bpOpen ? 'block' : 'none';
    if (this.bpOpen && this._backpackDirty) {
      this._backpackDirty = false;
      this.bpl.innerHTML = '';
      var tp = Object.keys(IT), hasItems = false, s = this;
      /* Show fishing rod if in inventory */
      if (this.inv.fishingRodCount > 0) {
        hasItems = true;
        var dv = document.createElement('div'); dv.className = 'backpack-item';
        var isEquipped = this.inv.equippedTool === 'fishing_rod';
        var btnLabel = isEquipped ? 'å·²è£…å¤‡ (ç‚¹å‡»å¸ä¸‹)' : 'è£…å¤‡';
        var btnStyle = isEquipped ? 'background:#f0c040;color:#333' : 'background:#446688;color:#fff';
        dv.innerHTML = '<span class="bp-icon">[ç«¿]</span><span class="bp-name">é±¼ç«¿</span><span class="bp-count">x' + this.inv.fishingRodCount + '</span><button style="margin-left:8px;padding:2px 8px;border:none;border-radius:4px;cursor:pointer;font-size:11px;' + btnStyle + '">' + btnLabel + '</button>';
        var btn = dv.querySelector('button');
        btn.addEventListener('click', function() {
          if (s.inv.equippedTool === 'fishing_rod') {
            s.inv.equippedTool = 'hook';
          } else {
            s.inv.equippedTool = 'fishing_rod';
          }
          s._updateTool1Slot();
          s._backpackDirty = true;
          if (s.onEquipChange) s.onEquipChange(s.inv.equippedTool);
        });
        this.bpl.appendChild(dv);
      }
      /* Show hook as equippable if fishing rod is equipped */
      if (this.inv.equippedTool === 'fishing_rod') {
        hasItems = true;
        var dv = document.createElement('div'); dv.className = 'backpack-item';
        dv.innerHTML = '<span class="bp-icon">[é’©]</span><span class="bp-name">é’©å­ï¼ˆé»˜è®¤ï¼‰</span><span class="bp-count"></span><button style="margin-left:8px;padding:2px 8px;border:none;border-radius:4px;cursor:pointer;font-size:11px;background:#446688;color:#fff">è£…å¤‡</button>';
        var btn = dv.querySelector('button');
        btn.addEventListener('click', function() {
          s.inv.equippedTool = 'hook';
          s._updateTool1Slot();
          s._backpackDirty = true;
          if (s.onEquipChange) s.onEquipChange(s.inv.equippedTool);
        });
        this.bpl.appendChild(dv);
      }
      for (var i = 0; i < tp.length; i++) {
        var cnt = this.inv.cnt(tp[i]);
        if (cnt > 0) {
          hasItems = true;
          var info = IT[tp[i]];
          var dv = document.createElement('div'); dv.className = 'backpack-item';
          dv.innerHTML = '<span class="bp-icon">[' + info.icon + ']</span><span class="bp-name">' + info.name + '</span><span class="bp-count">x' + cnt + '</span>';
          this.bpl.appendChild(dv);
        }
      }
      if (!hasItems) {
        var empty = document.createElement('div'); empty.className = 'backpack-empty';
        empty.textContent = 'èƒŒåŒ…æ˜¯ç©ºçš„ï¼Œç”¨é’©å­æ”¶é›†æµ·é¢ä¸Šçš„ç‰©å“å§ï¼';
        this.bpl.appendChild(empty);
      }
    }
    /* Demolish menu - only rebuild DOM when dirty */
    this.dmm.style.display = this.dmOpen ? 'block' : 'none';
    if (this.dmOpen && this._demolishDirty) {
      this._demolishDirty = false;
      this.dml.innerHTML = '';
      var items = this.ds.getDemolishableItems();
      if (items.length === 0) {
        var empty = document.createElement('div'); empty.className = 'demolish-empty';
        empty.textContent = 'æ²¡æœ‰å¯æ‹†é™¤çš„å»ºç­‘ç‰©';
        this.dml.appendChild(empty);
      } else {
        var s = this;
        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          var dv = document.createElement('div'); dv.className = 'demolish-item';
          var refundStr = this.ds.getRefundStr(item.cost);
          dv.innerHTML = '<span class="dm-icon">[' + item.icon + ']</span><span class="dm-name">' + item.name + ' x' + item.count + '</span><span class="dm-refund">' + refundStr + '</span>';
          (function(type) {
            dv.addEventListener('click', function() {
              s.ds.startPlace(type);
              s.dmOpen = false;
              s._updateUIState();
            });
          })(item.type);
          this.dml.appendChild(dv);
        }
      }
    }
    /* Crosshair is permanently hidden */
  }
}

/* ===== SaveManager - IndexedDB save/load system ===== */
class SaveManager {
  constructor() {
    this.dbName = 'RaftSurvivalDB';
    this.storeName = 'saves';
    this.saveKey = 'autosave';
    this.db = null;
    this.saveIndicator = document.getElementById('save-indicator');
  }
  /* Open (or create) the IndexedDB database */
  open() {
    var self = this;
    return new Promise(function(resolve, reject) {
      var req = indexedDB.open(self.dbName, 1);
      req.onupgradeneeded = function(e) {
        var db = e.target.result;
        if (!db.objectStoreNames.contains(self.storeName)) {
          db.createObjectStore(self.storeName, { keyPath: 'id' });
        }
      };
      req.onsuccess = function(e) { self.db = e.target.result; resolve(); };
      req.onerror = function(e) { reject(e.target.error); };
    });
  }
  /* Check if a save exists */
  hasSave() {
    var self = this;
    return new Promise(function(resolve) {
      if (!self.db) { resolve(false); return; }
      var tx = self.db.transaction(self.storeName, 'readonly');
      var store = tx.objectStore(self.storeName);
      var req = store.get(self.saveKey);
      req.onsuccess = function() { resolve(!!req.result); };
      req.onerror = function() { resolve(false); };
    });
  }
  /* Save game state to IndexedDB */
  save(gameState) {
    var self = this;
    return new Promise(function(resolve, reject) {
      if (!self.db) { reject('DB not open'); return; }
      var tx = self.db.transaction(self.storeName, 'readwrite');
      var store = tx.objectStore(self.storeName);
      var data = { id: self.saveKey, timestamp: Date.now(), state: gameState };
      var req = store.put(data);
      req.onsuccess = function() { self._showSaveIndicator(); resolve(); };
      req.onerror = function(e) { reject(e.target.error); };
    });
  }
  /* Load game state from IndexedDB */
  load() {
    var self = this;
    return new Promise(function(resolve, reject) {
      if (!self.db) { reject('DB not open'); return; }
      var tx = self.db.transaction(self.storeName, 'readonly');
      var store = tx.objectStore(self.storeName);
      var req = store.get(self.saveKey);
      req.onsuccess = function() { resolve(req.result ? req.result.state : null); };
      req.onerror = function(e) { reject(e.target.error); };
    });
  }
  /* Delete saved game */
  deleteSave() {
    var self = this;
    return new Promise(function(resolve, reject) {
      if (!self.db) { reject('DB not open'); return; }
      var tx = self.db.transaction(self.storeName, 'readwrite');
      var store = tx.objectStore(self.storeName);
      var req = store.delete(self.saveKey);
      req.onsuccess = function() { resolve(); };
      req.onerror = function(e) { reject(e.target.error); };
    });
  }
  /* Show save indicator briefly */
  _showSaveIndicator() {
    var el = this.saveIndicator;
    el.textContent = 'å·²ä¿å­˜ ' + new Date().toLocaleTimeString();
    el.classList.add('show');
    clearTimeout(this._hideTimer);
    this._hideTimer = setTimeout(function() { el.classList.remove('show'); }, 2000);
  }
}

/* ===== Game - main controller ===== */
class Game {
  constructor() { this.run = false; this.lt = 0; this.et = 0; this.saveManager = new SaveManager(); this.autoSaveTimer = 0; }
  init() {
    /* Scene, camera, renderer */
    this.sc = new THREE.Scene(); this.sc.fog = new THREE.Fog(CONFIG.FOG, CONFIG.FOG_N, CONFIG.FOG_F);
    this.cam = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    this.ren = new THREE.WebGLRenderer({ antialias: true });
    this.ren.setSize(window.innerWidth, window.innerHeight);
    this.ren.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.ren.shadowMap.enabled = true; this.ren.shadowMap.type = THREE.PCFSoftShadowMap;
    this.ren.setClearColor(CONFIG.SKY); document.body.appendChild(this.ren.domElement);
    /* Lighting */
    this.sc.add(new THREE.AmbientLight(0x6688aa, 0.6));
    this.sun = new THREE.DirectionalLight(0xfff4e0, 1.0); this.sun.position.set(50, 80, 30);
    this.sun.castShadow = true; this.sun.shadow.mapSize.width = 2048; this.sun.shadow.mapSize.height = 2048;
    this.sun.shadow.camera.near = 0.5; this.sun.shadow.camera.far = 200;
    this.sun.shadow.camera.left = -50; this.sun.shadow.camera.right = 50;
    this.sun.shadow.camera.top = 50; this.sun.shadow.camera.bottom = -50;
    this.sc.add(this.sun); this.sc.add(this.sun.target);
    this.sc.add(new THREE.HemisphereLight(0x87ceeb, 0x004466, 0.4));
    /* Sky dome */
    var sg = new THREE.SphereGeometry(400, 32, 16);
    var sm = new THREE.ShaderMaterial({
      uniforms: { topColor: { value: new THREE.Color(CONFIG.SKY) }, bottomColor: { value: new THREE.Color(0xb0d4f1) }, offset: { value: 20 }, exponent: { value: 0.6 } },
      vertexShader: 'varying vec3 vW;void main(){vec4 w=modelMatrix*vec4(position,1.0);vW=w.xyz;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}',
      fragmentShader: 'uniform vec3 topColor;uniform vec3 bottomColor;uniform float offset;uniform float exponent;varying vec3 vW;void main(){float h=normalize(vW+offset).y;gl_FragColor=vec4(mix(bottomColor,topColor,max(pow(max(h,0.0),exponent),0.0)),1.0);}',
      side: THREE.BackSide }); this.sky = new THREE.Mesh(sg, sm); this.sc.add(this.sky);
    /* Game systems */
    this.inp = new InputManager(); this.ocean = new Ocean(this.sc); this.raft = new Raft(this.sc);
    this.player = new Player(this.cam, this.raft, this.inp, this.sc); this.inv = new Inventory();
    this.spawner = new ItemSpawner(this.sc, this.raft);
    this.hook = new Hook(this.sc, this.player, this.spawner, this.inv);
    this.paddle = new Paddle(this.sc, this.player, this.raft, this.cam);
    this.purifier = new WaterPurifier(this.sc, this.raft, this.inv);
    this.fishing = new FishingSystem(this.sc, this.raft, this.inv, this.cam);
    this.bsys = new BuildSystem(this.raft, this.inv, this.sc, this.player, this.purifier);
    this.dsys = new DemolishSystem(this.raft, this.inv);
    /* Preallocated objects for main loop to avoid per-frame GC pressure */
    this._rc = new THREE.Raycaster();
    this._ndc = new THREE.Vector2();
    /* (placement mode now uses free cursor, no pointer lock needed) */
    this.ui = new UIManager(this.inv, this.bsys, this.inp, this.dsys);
    var s = this; this.hook.onC = function(t) { s.ui.col(t); };
    /* Equipment change callback: cancel fishing when switching away from rod */
    this.ui.onEquipChange = function(tool) {
      if (tool !== 'fishing_rod') s.fishing.cancel();
      s.ui._updateTool1Slot();
    };
    /* Key bindings */
    document.addEventListener('keydown', function(e) { if (!s.run) return;
      if (e.code === 'Digit1') {
        s.ui.closeAll(); s.ui.setA(0);
        if (s.inv.equippedTool === 'fishing_rod') {
          s.ui.tip('å·²è£…å¤‡é±¼ç«¿ - ç‚¹å‡»æµ·é¢é’“é±¼', 2);
          document.getElementById('fishing-hint').style.display = 'block';
        } else {
          document.getElementById('fishing-hint').style.display = 'none';
        }
      }
      if (e.code === 'Digit2') { s.ui.closeAll(); s.ui.setA(1); document.getElementById('fishing-hint').style.display = 'none'; }
      if (e.code === 'Digit3') { s.ui.toggleBuild(); }
      if (e.code === 'KeyB') { s.ui.toggleBuild(); }
      if (e.code === 'Digit4') { s.ui.toggleBackpack(); }
      if (e.code === 'Digit5') {
        /* God Mode: add 1,000,000 of each resource */
        var types = Object.keys(IT);
        for (var i = 0; i < types.length; i++) { s.inv.add(types[i], 1000000); }
        s.ui._buildMenuDirty = true; s.ui._backpackDirty = true; s.ui._demolishDirty = true;
        s.ui.tip('ä¸Šå¸æ¨¡å¼å·²æ¿€æ´»ï¼å„ç‰©èµ„ +1,000,000', 3);
      }
      if (e.code === 'Digit6') { s.ui.toggleDemolish(); }
      if (e.code === 'Digit7') { s.ui.toggleObserveMode(); }
      if (e.code === 'Escape') {
        if (s.dsys.placing) { s.dsys.cancelPlace(); s.ui.dmOpen = false; s.ui._updateUIState(); }
        else if (s.bsys.placing) { s.bsys.cancelPlace(); s.ui._updateUIState(); }
        else if (s.ui.isUIOpen()) { s.ui.closeAll(); }
      }
    });
    /* No pointer lock - mouse stays visible, right-click drag to rotate camera */
    window.addEventListener('resize', function() { s.cam.aspect = window.innerWidth / window.innerHeight;
      s.cam.updateProjectionMatrix(); s.ren.setSize(window.innerWidth, window.innerHeight); });
    this.ui.tip('WASD ç§»åŠ¨å°äººï¼Œå³é”®æ‹–æ‹½æ—‹è½¬è§†è§’ï¼Œå·¦é”®ç‚¹å‡»ä½¿ç”¨å·¥å…·', 4);
  }
  /* ===== Serialization: collect all game state into a plain object ===== */
  serializeState() {
    var state = {};
    /* Inventory */
    state.inventory = {};
    var types = Object.keys(IT);
    for (var i = 0; i < types.length; i++) { state.inventory[types[i]] = this.inv.cnt(types[i]); }
    /* Raft position */
    state.raftPos = { x: this.raft.g.position.x, y: this.raft.g.position.y, z: this.raft.g.position.z };
    state.raftVel = { x: this.raft.vel.x, y: this.raft.vel.y, z: this.raft.vel.z };
    /* Ground planks */
    state.planks = [];
    for (var i = 0; i < this.raft.planks.length; i++) {
      state.planks.push({ x: this.raft.planks[i].x, z: this.raft.planks[i].z });
    }
    /* Pillars */
    state.pillars = [];
    for (var i = 0; i < this.raft.pillars.length; i++) {
      var p = this.raft.pillars[i];
      state.pillars.push({ gx: p.gx, gz: p.gz, sx: p.sx, sz: p.sz, layer: p.layer });
    }
    /* Stairs */
    state.stairs = [];
    for (var i = 0; i < this.raft.stairs.length; i++) {
      var s = this.raft.stairs[i];
      state.stairs.push({ x: s.x, z: s.z, layer: s.layer });
    }
    /* Upper planks */
    state.upperPlanks = [];
    for (var i = 0; i < this.raft.upperPlanks.length; i++) {
      var u = this.raft.upperPlanks[i];
      state.upperPlanks.push({ x: u.x, z: u.z, layer: u.layer });
    }
    /* Storage boxes */
    state.storages = [];
    for (var i = 0; i < this.raft.storages.length; i++) {
      var st = this.raft.storages[i];
      state.storages.push({ gx: st.gx, gz: st.gz, sx: st.sx, sz: st.sz, layer: st.layer });
    }
    /* Player position and camera */
    state.player = {
      localX: this.player.localX, localZ: this.player.localZ,
      camYaw: this.player.camYaw, camPitch: this.player.camPitch,
      camDist: this.player.camDist, charYaw: this.player.charYaw,
      lastFloorY: this.player._lastFloorY || CONFIG.RPH / 2
    };
    /* Elapsed time */
    state.elapsedTime = this.et;
    /* Purifiers */
    state.purifiers = this.purifier.serialize();
    /* Fishing rod inventory */
    state.fishingRodCount = this.inv.fishingRodCount;
    state.equippedTool = this.inv.equippedTool;
    /* Freshwater and fish in inventory */
    state.inventory.freshwater = this.inv.cnt('freshwater');
    state.inventory.fish = this.inv.cnt('fish');
    return state;
  }
  /* ===== Deserialization: restore game state from a saved object ===== */
  restoreState(state) {
    if (!state) return;
    /* Restore inventory */
    if (state.inventory) {
      var types = Object.keys(IT);
      for (var i = 0; i < types.length; i++) { this.inv.it[types[i]] = state.inventory[types[i]] || 0; }
    }
    /* Clear existing raft structures (remove all meshes first) */
    /* Remove storages */
    while (this.raft.storages.length > 0) {
      var st = this.raft.storages[0];
      this.raft.g.remove(st.mesh);
      st.mesh.traverse(function(child) { if (child.geometry) child.geometry.dispose(); if (child.material) child.material.dispose(); });
      this.raft.storages.splice(0, 1);
    }
    this.raft.storageOcc.clear();
    /* Remove upper planks */
    while (this.raft.upperPlanks.length > 0) {
      var u = this.raft.upperPlanks[0];
      this.raft.g.remove(u.mesh);
      u.mesh.traverse(function(child) { if (child.geometry) child.geometry.dispose(); if (child.material) child.material.dispose(); });
      this.raft.upperPlanks.splice(0, 1);
    }
    this.raft.upperOcc.clear();
    /* Remove stairs */
    while (this.raft.stairs.length > 0) {
      var s = this.raft.stairs[0];
      this.raft.g.remove(s.mesh);
      s.mesh.traverse(function(child) { if (child.geometry) child.geometry.dispose(); if (child.material) child.material.dispose(); });
      this.raft.stairs.splice(0, 1);
    }
    this.raft.stairOcc.clear();
    /* Remove pillars */
    while (this.raft.pillars.length > 0) {
      var p = this.raft.pillars[0];
      this.raft.g.remove(p.mesh);
      p.mesh.traverse(function(child) { if (child.geometry) child.geometry.dispose(); if (child.material) child.material.dispose(); });
      this.raft.pillars.splice(0, 1);
    }
    this.raft.pillarOcc.clear();
    /* Remove ground planks */
    while (this.raft.planks.length > 0) {
      var pl = this.raft.planks[0];
      this.raft.g.remove(pl.mesh);
      pl.mesh.traverse(function(child) { if (child.geometry) child.geometry.dispose(); if (child.material) child.material.dispose(); });
      this.raft.planks.splice(0, 1);
    }
    this.raft.occ.clear();
    /* Rebuild ground planks */
    if (state.planks) {
      for (var i = 0; i < state.planks.length; i++) {
        this.raft.addPlank(state.planks[i].x, state.planks[i].z);
      }
    }
    /* Rebuild pillars */
    if (state.pillars) {
      for (var i = 0; i < state.pillars.length; i++) {
        var p = state.pillars[i];
        this.raft.addPillar(p.gx, p.gz, p.layer, p.sx, p.sz);
      }
    }
    /* Rebuild stairs */
    if (state.stairs) {
      for (var i = 0; i < state.stairs.length; i++) {
        var s = state.stairs[i];
        this.raft.addStairs(s.x, s.z, s.layer);
      }
    }
    /* Rebuild upper planks */
    if (state.upperPlanks) {
      for (var i = 0; i < state.upperPlanks.length; i++) {
        var u = state.upperPlanks[i];
        this.raft.addUpperPlank(u.x, u.z, u.layer);
      }
    }
    /* Rebuild storage boxes */
    if (state.storages) {
      for (var i = 0; i < state.storages.length; i++) {
        var st = state.storages[i];
        this.raft.addStorage(st.gx, st.gz, st.layer, st.sx, st.sz);
      }
    }
    /* Restore raft position and velocity */
    if (state.raftPos) {
      this.raft.g.position.set(state.raftPos.x, state.raftPos.y, state.raftPos.z);
    }
    if (state.raftVel) {
      this.raft.vel.set(state.raftVel.x, state.raftVel.y, state.raftVel.z);
    }
    /* Restore player position and camera */
    if (state.player) {
      this.player.localX = state.player.localX;
      this.player.localZ = state.player.localZ;
      this.player.camYaw = state.player.camYaw;
      this.player.camPitch = state.player.camPitch;
      this.player.camDist = state.player.camDist;
      this.player.charYaw = state.player.charYaw;
      this.player._lastFloorY = state.player.lastFloorY;
    }
    /* Restore elapsed time */
    if (state.elapsedTime !== undefined) {
      this.et = state.elapsedTime;
    }
    /* Restore purifiers */
    if (state.purifiers) {
      while (this.purifier.purifiers.length > 0) {
        this.purifier.removePurifier(this.purifier.purifiers[0].gx, this.purifier.purifiers[0].gz);
      }
      this.purifier.restore(state.purifiers);
    }
    /* Restore fishing rod and equipment */
    if (state.fishingRodCount !== undefined) {
      this.inv.fishingRodCount = state.fishingRodCount;
    }
    if (state.equippedTool) {
      this.inv.equippedTool = state.equippedTool;
      this.ui._updateTool1Slot();
    }
    /* Mark UI as dirty */
    this.ui._buildMenuDirty = true;
    this.ui._backpackDirty = true;
    this.ui._demolishDirty = true;
  }
  /* Trigger save (called after build/demolish operations) */
  triggerSave() {
    /* Reset observe mode cache so transparency gets reapplied to new structures */
    this._lastObsKey = null;
    var s = this;
    var state = this.serializeState();
    this.saveManager.save(state).catch(function(err) { console.warn('Save failed:', err); });
  }
  start() { this.run = true; document.getElementById('start-screen').style.display = 'none';
    document.getElementById('hud').style.display = 'block'; this.lt = performance.now();
    this.autoSaveTimer = 0;
    this._lp(); }
  _lp() { if (!this.run) return; var s = this; requestAnimationFrame(function() { s._lp(); });
    var now = performance.now(), dt = Math.min((now - this.lt) / 1000, 0.05); this.lt = now; this.et += dt;
    /* Auto-save every 30 seconds */
    this.autoSaveTimer += dt;
    if (this.autoSaveTimer >= 30) {
      this.autoSaveTimer = 0;
      this.triggerSave();
    }
    /* Handle mouse wheel: layer switching in placement mode, zoom otherwise */
    if (this.inp.wheelDelta !== 0) {
      if (this.bsys.placing) {
        this.bsys.changeLayer(this.inp.wheelDelta);
      } else {
        this.player.zoom(this.inp.wheelDelta);
      }
    }
    /* Tool usage - placement mode uses free cursor (no pointer lock needed) */
    if (this.inp.mjp && this.dsys.placing) {
      /* Demolish mode: raycast to find clicked demolish target - reuse preallocated rc/_ndc */
      var w = window.innerWidth, h = window.innerHeight;
      this._ndc.set((this.inp.mouseX / w) * 2 - 1, -(this.inp.mouseY / h) * 2 + 1);
      this._rc.setFromCamera(this._ndc, this.cam);
      var slots = this.raft.getSlotMeshes();
      if (slots.length > 0) {
        this.raft.g.updateMatrixWorld(true);
        var hits = this._rc.intersectObjects(slots);
        if (hits.length > 0) {
          var ud = hits[0].object.userData;
          var r = this.dsys.confirmDemolish(ud);
          if (r && r.ok) { this.ui.tip(r.msg); this.ui._buildMenuDirty = true; this.ui._backpackDirty = true; this.ui._demolishDirty = true; this.ui._updateUIState(); this.triggerSave(); }
          else if (r) { this.ui.tip(r.msg); }
        }
      }
    } else if (this.inp.mjp && this.bsys.placing) {
      /* Build placement mode: raycast to find clicked slot */
      var w = window.innerWidth, h = window.innerHeight;
      this._ndc.set((this.inp.mouseX / w) * 2 - 1, -(this.inp.mouseY / h) * 2 + 1);
      this._rc.setFromCamera(this._ndc, this.cam);
      /* Check purifier slots first */
      var purifierSlots = this.purifier.getSlotMeshes();
      var raftSlots = this.raft.getSlotMeshes();
      var allSlots = raftSlots.concat(purifierSlots);
      if (allSlots.length > 0) {
        this.raft.g.updateMatrixWorld(true);
        var hits = this._rc.intersectObjects(allSlots);
        if (hits.length > 0) {
          var ud = hits[0].object.userData;
          var r = this.bsys.confirmPlace(ud.gx, ud.gz, ud.layer, ud.sx, ud.sz);
          if (r && r.ok) { this.ui.tip(r.msg, 3); this.ui._buildMenuDirty = true; this.ui._backpackDirty = true; this.ui._demolishDirty = true; this.ui._updateUIState(); this.triggerSave(); }
        }
      }
    } else if (this.inp.mjp && !this.ui.isAnyOverlay()) {
      var w = window.innerWidth, h = window.innerHeight;
      this._ndc.set((this.inp.mouseX / w) * 2 - 1, -(this.inp.mouseY / h) * 2 + 1);
      if (this.ui.act === 0) {
        if (this.inv.equippedTool === 'fishing_rod') {
          /* Fishing mode: if biting - try to click fish; else cast to sea */
          if (this.fishing.state === 'biting') {
            var caught = this.fishing.tryClick(this.inp.mouseX, this.inp.mouseY, w, h);
            if (caught) {
              this.ui.tip('é’“åˆ°é±¼äº†ï¼é±¼å·²æ”¾å…¥èƒŒåŒ…', 3);
              this.ui._backpackDirty = true;
              this.ui.col('fish');
            }
          } else if (this.fishing.state === 'idle') {
            /* Raycast to sea surface (y=0 plane) */
            this._rc.setFromCamera(this._ndc, this.cam);
            var dir = this._rc.ray.direction, org = this._rc.ray.origin;
            if (dir.y < 0) {
              var t = -org.y / dir.y;
              if (t > 0 && t < 300) {
                var hitPos = new THREE.Vector3(org.x + dir.x * t, 0, org.z + dir.z * t);
                this.fishing.castAt(hitPos);
              }
            }
          }
        } else {
          /* Raycast from mouse to get hook throw direction */
          this._rc.setFromCamera(this._ndc, this.cam);
          this.hook.cast(this._rc.ray.direction);
        }
      }
      else if (this.ui.act === 1) this.paddle.setTarget(this.ocean, this._ndc);
      else if (this.ui.act === 2 && !this.bsys.open) { this.ui.toggleBuild(); }
    }
    /* Update observe mode transparency (only when state or layer changes) */
    var obsLayer = this.player.getCurrentLayer();
    var obsKey = (this.ui.observeMode ? 1 : 0) + ',' + obsLayer;
    if (this._lastObsKey !== obsKey) {
      this._lastObsKey = obsKey;
      this.raft.setObserveMode(this.ui.observeMode, obsLayer);
    }
    /* Update all systems */
    this.ocean.update(this.cam.position, this.et); this.raft.update(dt); this.player.update(dt);
    this.hook.update(dt); this.paddle.update(dt, this.et); this.spawner.update(dt, this.et); this.ui.update(dt);
    /* Update purifier - check if water was generated */
    var waterGenerated = this.purifier.update(dt);
    if (waterGenerated > 0) {
      this.ui.tip('å‡€åŒ–å™¨äº§ç”Ÿäº† ' + waterGenerated + ' å•ä½æ·¡æ°´ï¼', 2);
      this.ui._backpackDirty = true;
    }
    /* Update fishing system */
    var fishResult = this.fishing.update(dt);
    if (fishResult === 'timeout') {
      this.ui.tip('é±¼è·‘äº†ï¼', 2);
    }
    /* Sun + sky follow camera */
    this.sun.position.set(this.cam.position.x + 50, 80, this.cam.position.z + 30);
    this.sun.target.position.copy(this.cam.position); this.sun.target.updateMatrixWorld();
    this.sky.position.copy(this.cam.position);
    this.ren.render(this.sc, this.cam); this.inp.reset(); }
}

/* Entry point */
var game = new Game(); game.init();
/* Initialize save system and check for existing saves */
game.saveManager.open().then(function() {
  return game.saveManager.hasSave();
}).then(function(hasSave) {
  var continueBtn = document.getElementById('continue-btn');
  if (hasSave) {
    continueBtn.disabled = false;
    continueBtn.textContent = 'ç»§ç»­æ¸¸æˆ';
  } else {
    continueBtn.disabled = true;
    continueBtn.textContent = 'ç»§ç»­æ¸¸æˆï¼ˆæ— å­˜æ¡£ï¼‰';
  }
}).catch(function(err) { console.warn('IndexedDB init failed:', err); });
/* New game button */
document.getElementById('start-btn').addEventListener('click', function() {
  game.saveManager.deleteSave().catch(function() {});
  game.start();
});
/* Continue game button */
document.getElementById('continue-btn').addEventListener('click', function() {
  if (document.getElementById('continue-btn').disabled) return;
  game.saveManager.load().then(function(state) {
    if (state) {
      game.restoreState(state);
      game.start();
      game.ui.tip('æ¸¸æˆè¿›åº¦å·²æ¢å¤', 3);
    } else {
      game.start();
    }
  }).catch(function(err) { console.warn('Load failed:', err); game.start(); });
});
</script>
</body>
</html>